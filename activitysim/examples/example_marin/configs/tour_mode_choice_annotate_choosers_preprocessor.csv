Description,Target,Expression,
#,,,
,number_of_participants,1,
,is_joint,False,
#,,,
,_HAVE_PARENT_TOURS,False,
,_parent_tour_mode,False,
,work_tour_is_drive,False,
,work_tour_is_bike,False,
,work_tour_is_SOV,False,
#,,,
,is_mandatory,True,
,is_joint,False,
,is_indiv,~is_joint,
,is_atwork_subtour,False,
,is_escort,False,
#,,,
income_in_thousands,income_in_thousands,(df.HHINCADJ / 1000).clip(lower=0),
income_segment,income_segment,"pd.cut(income_in_thousands, bins=[-np.inf, 30, 60, 100, np.inf], labels=[1, 2, 3, 4]).astype(int)",
,demographic_segment,income_segment.map(TVPB_demographic_segments_by_income_segment),
#,c_ivt_for_segment,"np.where(demographic_segment==C_LOW_INCOME_SEGMENT_ID,c_ivt_low_income, c_ivt_high_income)",
#,c_cost_for_segment,"np.where(demographic_segment==C_LOW_INCOME_SEGMENT_ID,c_cost_low_income, c_cost_high_income)",
#,,,
#,c_cost,(0.60 * c_ivt) / df.value_of_time,
# ivot * (c_ivt_cost_multiplier * c_ivt),,,
,ivot,1.0 / df.value_of_time,
# RIDEHAIL,,,
,origin_density_measure,"(reindex(land_use.POP, df[orig_col_name]) + reindex(land_use.emp_total, df[orig_col_name])) / (reindex(land_use.ACRES, df[orig_col_name]) / 640)",
,dest_density_measure,"(reindex(land_use.POP, df[dest_col_name]) + reindex(land_use.emp_total, df[dest_col_name])) / (reindex(land_use.ACRES, df[dest_col_name]) / 640)",
,origin_density,"pd.cut(origin_density_measure, bins=[-np.inf, 500, 2000, 5000, 15000, np.inf], labels=[5, 4, 3, 2, 1]).astype(int)",
,dest_density,"pd.cut(dest_density_measure, bins=[-np.inf, 500, 2000, 5000, 15000, np.inf], labels=[5, 4, 3, 2, 1]).astype(int)",
,origin_zone_taxi_wait_time_mean,"origin_density.map({k: v for k, v in Taxi_waitTime_mean.items()})",
,origin_zone_taxi_wait_time_sd,"origin_density.map({k: v for k, v in Taxi_waitTime_sd.items()})",
,dest_zone_taxi_wait_time_mean,"dest_density.map({k: v for k, v in Taxi_waitTime_mean.items()})",
,dest_zone_taxi_wait_time_sd,"dest_density.map({k: v for k, v in Taxi_waitTime_sd.items()})",
# ,, Note that the mean and standard deviation are not the values for the distribution itself, but of the underlying normal distribution it is derived from
,origTaxiWaitTime,"rng.lognormal_for_df(df, mu=origin_zone_taxi_wait_time_mean, sigma=origin_zone_taxi_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,destTaxiWaitTime,"rng.lognormal_for_df(df, mu=dest_zone_taxi_wait_time_mean, sigma=dest_zone_taxi_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,origin_zone_singleTNC_wait_time_mean,"origin_density.map({k: v for k, v in TNC_single_waitTime_mean.items()})",
,origin_zone_singleTNC_wait_time_sd,"origin_density.map({k: v for k, v in TNC_single_waitTime_sd.items()})",
,dest_zone_singleTNC_wait_time_mean,"dest_density.map({k: v for k, v in TNC_single_waitTime_mean.items()})",
,dest_zone_singleTNC_wait_time_sd,"dest_density.map({k: v for k, v in TNC_single_waitTime_sd.items()})",
,origSingleTNCWaitTime,"rng.lognormal_for_df(df, mu=origin_zone_singleTNC_wait_time_mean, sigma=origin_zone_singleTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,destSingleTNCWaitTime,"rng.lognormal_for_df(df, mu=dest_zone_singleTNC_wait_time_mean, sigma=dest_zone_singleTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,origin_zone_sharedTNC_wait_time_mean,"origin_density.map({k: v for k, v in TNC_shared_waitTime_mean.items()})",
,origin_zone_sharedTNC_wait_time_sd,"origin_density.map({k: v for k, v in TNC_shared_waitTime_sd.items()})",
,dest_zone_sharedTNC_wait_time_mean,"dest_density.map({k: v for k, v in TNC_shared_waitTime_mean.items()})",
,dest_zone_sharedTNC_wait_time_sd,"dest_density.map({k: v for k, v in TNC_shared_waitTime_sd.items()})",
,origSharedTNCWaitTime,"rng.lognormal_for_df(df, mu=origin_zone_sharedTNC_wait_time_mean, sigma=origin_zone_sharedTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,destSharedTNCWaitTime,"rng.lognormal_for_df(df, mu=dest_zone_sharedTNC_wait_time_mean, sigma=dest_zone_sharedTNC_wait_time_sd, broadcast=True, scale=True).clip(min_waitTime, max_waitTime)",
,totalWaitTaxi,origTaxiWaitTime + destTaxiWaitTime,
,totalWaitSingleTNC,origSingleTNCWaitTime + destSingleTNCWaitTime,
,totalWaitSharedTNC,origSharedTNCWaitTime + destSharedTNCWaitTime,
#,,,
,_free_parking_available,(df.tour_type == 'work') & (df.fp_choice == 1),
,_dest_hourly_peak_parking_cost,"reindex(land_use.hparkcost, df[dest_col_name])",
,_dest_hourly_offpeak_parking_cost,"reindex(land_use.hparkcost, df[dest_col_name])",
,_hourly_peak_parking_cost,"np.where(_free_parking_available, 0, _dest_hourly_peak_parking_cost)",
,_hourly_offpeak_parking_cost,"np.where(_free_parking_available, 0, _dest_hourly_offpeak_parking_cost)",
just hourly instead of times duration for now,daily_parking_cost,"np.where(is_mandatory, _hourly_peak_parking_cost, _hourly_offpeak_parking_cost)",
#,,,
,distance,(odt_skims['DISTDA']),
,sov_available,(odt_skims['TIMEDA']>0) & (dot_skims['TIMEDA']>0),
,sovtoll_available,(odt_skims['TOLLVTOLLDA']>0) | (dot_skims['TOLLVTOLLDA']>0),
,hov2_available,(odt_skims['TIMES2'] + dot_skims['TIMES2'])>0,
,hov2toll_available,(odt_skims['TOLLVTOLLS2'] + dot_skims['TOLLVTOLLS2'])>0,
,hov3_available,(odt_skims['TIMES3']>0) & (dot_skims['TIMES3']>0),
,hov3toll_available,(odt_skims['TOLLVTOLLS3'] + dot_skims['TOLLVTOLLS3'])>0,
,walk_available,"od_skims.lookup('WALK_DIST').between(0.01, walkThresh) & od_skims.reverse('WALK_DIST').between(0.01, walkThresh)",
,bike_available,"od_skims.lookup('BIKE_DIST').between(0.01, bikeThresh) & od_skims.reverse('BIKE_DIST').between(0.01, bikeThresh)",
#,,,
destination district,destination_in_cbd_sf,"reindex(land_use.DistID, df[dest_col_name])==1",
destination district,destination_in_nw_sf,"reindex(land_use.DistID, df[dest_col_name])==2",
destination district,destination_in_se_sf,"reindex(land_use.DistID, df[dest_col_name])==3",
#,,,
,origin_terminal_time,"reindex(land_use.TERMINALTIME, df[orig_col_name])",
,dest_terminal_time,"reindex(land_use.TERMINALTIME, df[dest_col_name])",
,origin_DUDen,"reindex(land_use.DUDen, df[orig_col_name])",
,dest_DUDen,"reindex(land_use.DUDen, df[dest_col_name])",
,origin_EmpDen,"reindex(land_use.EmpDen, df[orig_col_name])",
,dest_EmpDen,"reindex(land_use.EmpDen, df[dest_col_name])",
,origin_TotInt,"reindex(land_use.TotInt, df[orig_col_name])",
,dest_TotInt,"reindex(land_use.TotInt, df[dest_col_name])",
,origin_Mix,"(origin_DUDen * origin_EmpDen) / np.where((origin_DUDen + origin_EmpDen) > 0, (origin_DUDen + origin_EmpDen), 0.001)",
,dest_Mix,"(dest_DUDen * dest_EmpDen) / np.where((dest_DUDen + dest_EmpDen) > 0, (dest_DUDen + dest_EmpDen), 0.001)",
# diagnostic,,,
#,sov_dist_roundtrip,(odt_skims['DISTDA'] + dot_skims['DISTDA']),
