

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Core Components &mdash; ActivitySim 0.3dev1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="ActivitySim 0.3dev1 documentation" href="index.html"/>
        <link rel="next" title="Models" href="models.html"/>
        <link rel="prev" title="Data Schema" href="dataschema.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> ActivitySim
          

          
          </a>

          
            
            
              <div class="version">
                0.3dev1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="gettingstarted.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="howitworks.html">How the System Works</a></li>
<li class="toctree-l1"><a class="reference internal" href="dataschema.html">Data Schema</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Core Components</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#simulate">Simulate</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-activitysim.core.simulate">API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#skim">Skim</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#logit">Logit</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pipeline">Pipeline</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id3">API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#random">Random</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tracing">Tracing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id5">API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#assign">Assign</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#utilities">Utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id7">API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#config">Config</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id8">API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#inject-defaults">Inject_Defaults</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id9">API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tests">Tests</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="models.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="development.html">Development</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ActivitySim</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Core Components</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/core.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="core-components">
<h1>Core Components<a class="headerlink" href="#core-components" title="Permalink to this headline">¶</a></h1>
<p>ActivitySim’s core components include the model specification reader and expression
evaluator, the skim matrix manager, the simulate methods for solving
models (i.e. calculating utilities, probabilties, and making choices),  the choice
models, the data pipeline manager, the random number generator, and the tracer.</p>
<div class="section" id="simulate">
<h2>Simulate<a class="headerlink" href="#simulate" title="Permalink to this headline">¶</a></h2>
<p>Methods for expression handling, solving, choosing (i.e. making choices), and for identifying chunks</p>
<div class="section" id="module-activitysim.core.simulate">
<span id="api"></span><h3>API<a class="headerlink" href="#module-activitysim.core.simulate" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="activitysim.core.simulate.add_skims">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">add_skims</code><span class="sig-paren">(</span><em>df</em>, <em>skims</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.add_skims" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the dataframe to the SkimDictWrapper object so that it can be dereferenced
using the parameters of the skims object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>df</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>Table to which to add skim data as new columns.
<cite>df</cite> is modified in-place.</p>
</div></blockquote>
<p><strong>skims</strong> : SkimDictWrapper object</p>
<blockquote class="last">
<div><p>The skims object is used to contain multiple matrices of
origin-destination impedances.  Make sure to also add it to the
locals_d below in order to access it in expressions.  The <em>only</em> job
of this method in regards to skims is to call set_df with the
dataframe that comes back from interacting choosers with
alternatives.  See the skims module for more documentation on how
the skims object is intended to be used.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.compute_base_probabilities">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">compute_base_probabilities</code><span class="sig-paren">(</span><em>nested_probabilities</em>, <em>nests</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.compute_base_probabilities" title="Permalink to this definition">¶</a></dt>
<dd><p>compute base probabilities for nest leaves
Base probabilities will be the nest-adjusted probabilities of all leaves
This flattens or normalizes all the nested probabilities so that they have the proper global
relative values (the leaf probabilities sum to 1 for each row.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nested_probabilities</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>dataframe with the nested probabilities for nest leafs and nodes</p>
</div></blockquote>
<p><strong>nest_spec</strong> : dict</p>
<blockquote>
<div><p>Nest tree dict from the model spec yaml file</p>
</div></blockquote>
<p><strong>Returns</strong></p>
<p><strong>——-</strong></p>
<p><strong>base_probabilities</strong> : pandas.DataFrame</p>
<blockquote class="last">
<div><p>Will have the index of <cite>nested_probabilities</cite> and columns for leaf base probabilities</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.compute_nested_exp_utilities">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">compute_nested_exp_utilities</code><span class="sig-paren">(</span><em>raw_utilities</em>, <em>nest_spec</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.compute_nested_exp_utilities" title="Permalink to this definition">¶</a></dt>
<dd><p>compute exponentiated nest utilities based on nesting coefficients</p>
<p>For nest nodes this is the exponentiated logsum of alternatives adjusted by nesting coefficient</p>
<p>leaf &lt;- exp( raw_utility )
nest &lt;- exp( ln(sum of exponentiated raw_utility of leaves) * nest_coefficient)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>raw_utilities</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>dataframe with the raw alternative utilities of all leaves
(what in non-nested logit would be the utilities of all the alternatives)</p>
</div></blockquote>
<p><strong>nest_spec</strong> : dict</p>
<blockquote>
<div><p>Nest tree dict from the model spec yaml file</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>nested_utilities</strong> : pandas.DataFrame</p>
<blockquote class="last">
<div><p>Will have the index of <cite>raw_utilities</cite> and columns for exponentiated leaf and node utilities</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.compute_nested_probabilities">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">compute_nested_probabilities</code><span class="sig-paren">(</span><em>nested_exp_utilities</em>, <em>nest_spec</em>, <em>trace_label</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.compute_nested_probabilities" title="Permalink to this definition">¶</a></dt>
<dd><p>compute nested probabilities for nest leafs and nodes
probability for nest alternatives is simply the alternatives’s local (to nest) probability
computed in the same way as the probability of non-nested alternatives in multinomial logit
i.e. the fractional share of the sum of the exponentiated utility of itself and its siblings
except in nested logit, its sib group is restricted to the nest</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nested_exp_utilities</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>dataframe with the exponentiated nested utilities of all leaves and nodes</p>
</div></blockquote>
<p><strong>nest_spec</strong> : dict</p>
<blockquote>
<div><p>Nest tree dict from the model spec yaml file</p>
</div></blockquote>
<p><strong>Returns</strong></p>
<p><strong>——-</strong></p>
<p><strong>nested_probabilities</strong> : pandas.DataFrame</p>
<blockquote class="last">
<div><p>Will have the index of <cite>nested_exp_utilities</cite> and columns for leaf and node probabilities</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.eval_interaction_utilities">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">eval_interaction_utilities</code><span class="sig-paren">(</span><em>spec</em>, <em>df</em>, <em>locals_d</em>, <em>trace_label</em>, <em>trace_rows</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.eval_interaction_utilities" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the utilities for a single-alternative spec evaluated in the context of df</p>
<p>We could compute the utilities for interaction datasets just as we do for simple_simulate
specs with multiple alternative columns byt calling eval_variables and then computing the
utilities by matrix-multiplication of eval results with the utility coefficients in the
spec alternative columns.</p>
<p>But interaction simulate computes the utilities of each alternative in the context of a
separate row in interaction dataset df, and so there is only one alternative in spec.
This turns out to be quite a bit faster (in this special case) than the pandas dot function.</p>
<p>For efficiency, we combine eval_variables and multiplication of coefficients into a single step,
so we don’t have to create a separate column for each partial utility. Instead, we simply
multiply the eval result by a single alternative coefficient and sum the partial utilities.</p>
<dl class="docutils">
<dt>spec <span class="classifier-delimiter">:</span> <span class="classifier">dataframe</span></dt>
<dd>one row per spec expression and one col with utility coefficient</dd>
<dt>df <span class="classifier-delimiter">:</span> <span class="classifier">dataframe</span></dt>
<dd>cross join (cartesian product) of choosers with alternatives
combines columns of choosers and alternatives
len(df) == len(choosers) * len(alternatives)
index values (non-unique) are index values from alternatives df</dd>
<dt>interaction_utilities <span class="classifier-delimiter">:</span> <span class="classifier">dataframe</span></dt>
<dd>the utility of each alternative is sum of the partial utilities determined by the
various spec expressions and their corresponding coefficients
yielding a dataframe  with len(interaction_df) rows and one utility column
having the same index as interaction_df (non-unique values from alternatives df)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>utilities</strong> : pandas.DataFrame</p>
<blockquote class="last">
<div><p>Will have the index of <cite>df</cite> and a single column of utilities</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.eval_mnl">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">eval_mnl</code><span class="sig-paren">(</span><em>choosers</em>, <em>spec</em>, <em>locals_d=None</em>, <em>trace_label=None</em>, <em>trace_choice_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.eval_mnl" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a simulation for when the model spec does not involve alternative
specific data, e.g. there are no interactions with alternative
properties and no need to sample from alternatives.</p>
<p>Each row in spec computes a partial utility for each alternative,
by providing a spec expression (often a boolean 0-1 trigger)
and a column of utility coefficients for each alternative.</p>
<p>We compute the utility of each alternative by matrix-multiplication of eval results
with the utility coefficients in the spec alternative columns
yielding one row per chooser and one column per alternative</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>choosers</strong> : pandas.DataFrame</p>
<p><strong>spec</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>A table of variable specifications and coefficient values.
Variable expressions should be in the table index and the table
should have a column for each alternative.</p>
</div></blockquote>
<p><strong>locals_d</strong> : Dict</p>
<blockquote>
<div><p>This is a dictionary of local variables that will be the environment
for an evaluation of an expression that begins with &#64;</p>
</div></blockquote>
<p><strong>trace_label: str</strong></p>
<blockquote>
<div><p>This is the label to be used  for trace log file entries and dump file names
when household tracing enabled. No tracing occurs if label is empty or None.</p>
</div></blockquote>
<p><strong>trace_choice_name: str</strong></p>
<blockquote>
<div><p>This is the column label to be used in trace file csv dump of choices</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>choices</strong> : pandas.Series</p>
<blockquote class="last">
<div><p>Index will be that of <cite>choosers</cite>, values will match the columns
of <cite>spec</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.eval_nl">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">eval_nl</code><span class="sig-paren">(</span><em>choosers</em>, <em>spec</em>, <em>nest_spec</em>, <em>locals_d=None</em>, <em>trace_label=None</em>, <em>trace_choice_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.eval_nl" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a nested-logit simulation for when the model spec does not involve alternative
specific data, e.g. there are no interactions with alternative
properties and no need to sample from alternatives.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>choosers</strong> : pandas.DataFrame</p>
<p><strong>spec</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>A table of variable specifications and coefficient values.
Variable expressions should be in the table index and the table
should have a column for each alternative.</p>
</div></blockquote>
<p><strong>nest_spec:</strong></p>
<blockquote>
<div><p>dictionary specifying nesting structure and nesting coefficients
(from the model spec yaml file)</p>
</div></blockquote>
<p><strong>locals_d</strong> : Dict</p>
<blockquote>
<div><p>This is a dictionary of local variables that will be the environment
for an evaluation of an expression that begins with &#64;</p>
</div></blockquote>
<p><strong>trace_label: str</strong></p>
<blockquote>
<div><p>This is the label to be used  for trace log file entries and dump file names
when household tracing enabled. No tracing occurs if label is empty or None.</p>
</div></blockquote>
<p><strong>trace_choice_name: str</strong></p>
<blockquote>
<div><p>This is the column label to be used in trace file csv dump of choices</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>choices</strong> : pandas.Series</p>
<blockquote class="last">
<div><p>Index will be that of <cite>choosers</cite>, values will match the columns
of <cite>spec</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.eval_variables">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">eval_variables</code><span class="sig-paren">(</span><em>exprs</em>, <em>df</em>, <em>locals_d=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.eval_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a set of variable expressions from a spec in the context
of a given data table.</p>
<p>There are two kinds of supported expressions: “simple” expressions are
evaluated in the context of the DataFrame using DataFrame.eval.
This is the default type of expression.</p>
<p>Python expressions are evaluated in the context of this function using
Python’s eval function. Because we use Python’s eval this type of
expression supports more complex operations than a simple expression.
Python expressions are denoted by beginning with the &#64; character.
Users should take care that these expressions must result in
a Pandas Series.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>exprs</strong> : sequence of str</p>
<p><strong>df</strong> : pandas.DataFrame</p>
<p><strong>locals_d</strong> : Dict</p>
<blockquote>
<div><p>This is a dictionary of local variables that will be the environment
for an evaluation of an expression that begins with &#64;</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>variables</strong> : pandas.DataFrame</p>
<blockquote class="last">
<div><p>Will have the index of <cite>df</cite> and columns of <cite>exprs</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.interaction_simulate">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">interaction_simulate</code><span class="sig-paren">(</span><em>choosers</em>, <em>alternatives</em>, <em>spec</em>, <em>skims=None</em>, <em>locals_d=None</em>, <em>sample_size=None</em>, <em>chunk_size=0</em>, <em>trace_label=None</em>, <em>trace_choice_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.interaction_simulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a simulation in the situation in which alternatives must
be merged with choosers because there are interaction terms or
because alternatives are being sampled.</p>
<p>optionally (if chunk_size &gt; 0) iterates over choosers in chunk_size chunks</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>choosers</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>DataFrame of choosers</p>
</div></blockquote>
<p><strong>alternatives</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>DataFrame of alternatives - will be merged with choosers, currently
without sampling</p>
</div></blockquote>
<p><strong>spec</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>A Pandas DataFrame that gives the specification of the variables to
compute and the coefficients for each variable.
Variable specifications must be in the table index and the
table should have only one column of coefficients.</p>
</div></blockquote>
<p><strong>skims</strong> : Skims object</p>
<blockquote>
<div><p>The skims object is used to contain multiple matrices of
origin-destination impedances.  Make sure to also add it to the
locals_d below in order to access it in expressions.  The <em>only</em> job
of this method in regards to skims is to call set_df with the
dataframe that comes back from interacting choosers with
alternatives.  See the skims module for more documentation on how
the skims object is intended to be used.</p>
</div></blockquote>
<p><strong>locals_d</strong> : Dict</p>
<blockquote>
<div><p>This is a dictionary of local variables that will be the environment
for an evaluation of an expression that begins with &#64;</p>
</div></blockquote>
<p><strong>sample_size</strong> : int, optional</p>
<blockquote>
<div><p>Sample alternatives with sample of given size.  By default is None,
which does not sample alternatives.</p>
</div></blockquote>
<p><strong>chunk_size</strong> : int</p>
<blockquote>
<div><p>if chunk_size &gt; 0 iterates over choosers in chunk_size chunks</p>
</div></blockquote>
<p><strong>trace_label: str</strong></p>
<blockquote>
<div><p>This is the label to be used  for trace log file entries and dump file names
when household tracing enabled. No tracing occurs if label is empty or None.</p>
</div></blockquote>
<p><strong>trace_choice_name: str</strong></p>
<blockquote>
<div><p>This is the column label to be used in trace file csv dump of choices</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>ret</strong> : pandas.Series</p>
<blockquote class="last">
<div><p>A series where index should match the index of the choosers DataFrame
and values will match the index of the alternatives DataFrame -
choices are simulated in the standard Monte Carlo fashion</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.read_model_spec">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">read_model_spec</code><span class="sig-paren">(</span><em>fname</em>, <em>description_name=’Description’</em>, <em>expression_name=’Expression’</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.read_model_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a CSV model specification into a Pandas DataFrame or Series.</p>
<p>The CSV is expected to have columns for component descriptions
and expressions, plus one or more alternatives.</p>
<p>The CSV is required to have a header with column names. For example:</p>
<blockquote>
<div>Description,Expression,alt0,alt1,alt2</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fname</strong> : str</p>
<blockquote>
<div><p>Name of a CSV spec file.</p>
</div></blockquote>
<p><strong>description_name</strong> : str, optional</p>
<blockquote>
<div><p>Name of the column in <cite>fname</cite> that contains the component description.</p>
</div></blockquote>
<p><strong>expression_name</strong> : str, optional</p>
<blockquote>
<div><p>Name of the column in <cite>fname</cite> that contains the component expression.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>spec</strong> : pandas.DataFrame</p>
<blockquote class="last">
<div><p>The description column is dropped from the returned data and the
expression values are set as the table index.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.simple_simulate">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">simple_simulate</code><span class="sig-paren">(</span><em>choosers</em>, <em>spec</em>, <em>nest_spec</em>, <em>skims=None</em>, <em>locals_d=None</em>, <em>trace_label=None</em>, <em>trace_choice_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.simple_simulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Run an MNL or NL simulation for when the model spec does not involve alternative
specific data, e.g. there are no interactions with alternative
properties and no need to sample from alternatives.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>choosers</strong> : pandas.DataFrame</p>
<p><strong>spec</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>A table of variable specifications and coefficient values.
Variable expressions should be in the table index and the table
should have a column for each alternative.</p>
</div></blockquote>
<p><strong>nest_spec:</strong></p>
<blockquote>
<div><p>for nested logit (nl): dictionary specifying nesting structure and nesting coefficients
for multinomial logit (mnl): None</p>
</div></blockquote>
<p><strong>skims</strong> : Skims object</p>
<blockquote>
<div><p>The skims object is used to contain multiple matrices of
origin-destination impedances.  Make sure to also add it to the
locals_d below in order to access it in expressions.  The <em>only</em> job
of this method in regards to skims is to call set_df with the
dataframe that comes back from interacting choosers with
alternatives.  See the skims module for more documentation on how
the skims object is intended to be used.</p>
</div></blockquote>
<p><strong>locals_d</strong> : Dict</p>
<blockquote>
<div><p>This is a dictionary of local variables that will be the environment
for an evaluation of an expression that begins with &#64;</p>
</div></blockquote>
<p><strong>trace_label: str</strong></p>
<blockquote>
<div><p>This is the label to be used  for trace log file entries and dump file names
when household tracing enabled. No tracing occurs if label is empty or None.</p>
</div></blockquote>
<p><strong>trace_choice_name: str</strong></p>
<blockquote>
<div><p>This is the column label to be used in trace file csv dump of choices</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>choices</strong> : pandas.Series</p>
<blockquote class="last">
<div><p>Index will be that of <cite>choosers</cite>, values will match the columns
of <cite>spec</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="skim">
<span id="skims-in-detail"></span><h2>Skim<a class="headerlink" href="#skim" title="Permalink to this headline">¶</a></h2>
<p>Skim matrix data access</p>
<div class="section" id="id1">
<h3>API<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-activitysim.core.skim"></span><dl class="class">
<dt id="activitysim.core.skim.SkimDict">
<em class="property">class </em><code class="descclassname">activitysim.core.skim.</code><code class="descname">SkimDict</code><a class="headerlink" href="#activitysim.core.skim.SkimDict" title="Permalink to this definition">¶</a></dt>
<dd><p>A SkimDict object is a wrapper around a dict of multiple skim objects,
where each object is identified by a key.  It operates like a
dictionary - i.e. use brackets to add and get skim objects.</p>
<p>Note that keys are either strings or tuples of two strings (to support stacking of skims.)</p>
<dl class="method">
<dt id="activitysim.core.skim.SkimDict.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimDict.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an available skim object (not the lookup)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : hashable</p>
<blockquote>
<div><p>The key (identifier) for this skim object</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">skim: Skim</p>
<blockquote class="last">
<div><p>The skim object</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.skim.SkimDict.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>key</em>, <em>skim_data</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimDict.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set skim data for key</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : hashable</p>
<blockquote>
<div><p>The key (identifier) for this skim object</p>
</div></blockquote>
<p><strong>skim_data</strong> : Skim</p>
<blockquote>
<div><p>The skim object</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Nothing</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.skim.SkimDict.wrap">
<code class="descname">wrap</code><span class="sig-paren">(</span><em>left_key</em>, <em>right_key</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimDict.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>return a SkimDictWrapper for self</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="activitysim.core.skim.SkimDictWrapper">
<em class="property">class </em><code class="descclassname">activitysim.core.skim.</code><code class="descname">SkimDictWrapper</code><span class="sig-paren">(</span><em>skim_dict</em>, <em>left_key</em>, <em>right_key</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimDictWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>A SkimDictWrapper object is an access wrapper around a SkimDict of multiple skim objects,
where each object is identified by a key.  It operates like a
dictionary - i.e. use brackets to add and get skim objects - but also
has information on how to lookup against the skim objects.
Specifically, this object has a dataframe, a left_key and right_key.
It is assumed that left_key and right_key identify columns in df.  The
parameter df is usually set by the simulation itself as it’s a result of
interacting choosers and alternatives.</p>
<p>When the user calls skims[key], key is an identifier for which skim
to use, and the object automatically looks up impedances of that skim
using the specified left_key column in df as the origin and
the right_key column in df as the destination.  In this way, the user
does not do the O-D lookup by hand and only specifies which skim to use
for this lookup.  This is the only purpose of this object: to
abstract away the O-D lookup and use skims by specifying which skim
to use in the expressions.</p>
<p>Note that keys are either strings or tuples of two strings (to support stacking of skims.)</p>
<dl class="method">
<dt id="activitysim.core.skim.SkimDictWrapper.lookup">
<code class="descname">lookup</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimDictWrapper.lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Generally not called by the user - use __getitem__ instead</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>key</strong> : hashable</p>
<blockquote>
<div><p>The key (identifier) for this skim object</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">impedances: pd.Series</p>
<blockquote class="last">
<div><p>A Series of impedances which are elements of the Skim object and
with the same index as df</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.skim.SkimDictWrapper.set_df">
<code class="descname">set_df</code><span class="sig-paren">(</span><em>df</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimDictWrapper.set_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the dataframe</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>df</strong> : DataFrame</p>
<blockquote>
<div><p>The dataframe which contains the origin and destination ids</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Nothing</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="activitysim.core.skim.SkimStackWrapper">
<em class="property">class </em><code class="descclassname">activitysim.core.skim.</code><code class="descname">SkimStackWrapper</code><span class="sig-paren">(</span><em>stack</em>, <em>left_key</em>, <em>right_key</em>, <em>skim_key</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimStackWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>A SkimStackWrapper object wraps a skims object to add an additional wrinkle of
lookup functionality.  Upon init the separate skims objects are
processed into a 3D matrix so that lookup of the different skims can
be performed quickly for each row in the dataframe.  In this very
particular formulation, the keys are assumed to be tuples with two
elements - the second element of which will be taken from the
different rows in the dataframe.  The first element can then be
dereferenced like an array.  This is useful, for instance, to have a
certain skim vary by time of day - the skims are set with keys of
(‘SOV’, ‘AM”), (‘SOV’, ‘PM’) etc.  The time of day is then taken to
be different for every row in the tours table, and the ‘SOV’ portion
of the key can be used in __getitem__.</p>
<p>To be more explicit, the input is a dictionary of Skims objects, each of
which contains a 2D matrix.  These are stacked into a 3D matrix with a
mapping of keys to indexes which is applied using pandas .map to a third
column in the object dataframe.  The three columns - left_key and
right_key from the Skims object and skim_key from this one, are then used to
dereference the 3D matrix.  The tricky part comes in defining the key which
matches the 3rd dimension of the matrix, and the key which is passed into
__getitem__ below (i.e. the one used in the specs).  By convention,
every key in the Skims object that is passed in MUST be a tuple with 2
items.  The second item in the tuple maps to the items in the dataframe
referred to by the skim_key column and the first item in the tuple is
then available to pass directly to __getitem__.</p>
<p>The sum conclusion of this is that in the specs, you can say something
like out_skim[‘SOV’] and it will automatically dereference the 3D matrix
using origin, destination, and time of day.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>skims: Skims</strong></p>
<blockquote>
<div><p>This is the Skims object to wrap</p>
</div></blockquote>
<p><strong>skim_key</strong> : str</p>
<blockquote class="last">
<div><p>This identifies the column in the dataframe which is used to
select among Skim object using the SECOND item in each tuple (see
above for a more complete description)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="activitysim.core.skim.SkimStackWrapper.set_df">
<code class="descname">set_df</code><span class="sig-paren">(</span><em>df</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimStackWrapper.set_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the dataframe</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>df</strong> : DataFrame</p>
<blockquote>
<div><p>The dataframe which contains the origin and destination ids</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Nothing</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="activitysim.core.skim.SkimWrapper">
<em class="property">class </em><code class="descclassname">activitysim.core.skim.</code><code class="descname">SkimWrapper</code><span class="sig-paren">(</span><em>data</em>, <em>offset_mapper=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for skim arrays.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>data</strong> : 2D array</p>
<p><strong>offset</strong> : int, optional</p>
<blockquote class="last">
<div><p>An optional offset that will be added to origin/destination
values to turn them into array indices.
For example, if zone IDs are 1-based, an offset of -1
would turn them into 0-based array indices.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="activitysim.core.skim.SkimWrapper.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>orig</em>, <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimWrapper.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get impedence values for a set of origin, destination pairs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>orig</strong> : 1D array</p>
<p><strong>dest</strong> : 1D array</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>values</strong> : 1D array</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="logit">
<span id="logit-in-detail"></span><h2>Logit<a class="headerlink" href="#logit" title="Permalink to this headline">¶</a></h2>
<p>Multinomial logit (MNL) or Nested logit (NL) choice model.  These choice models depend on the foundational components of ActivitySim, such
as the expressions and data handling described in the <a class="reference internal" href="howitworks.html#id1"><span class="std std-ref">Execution Flow</span></a> section.</p>
<p>To specify and solve an MNL model:</p>
<ul class="simple">
<li>either specify <code class="docutils literal"><span class="pre">LOGIT_TYPE:</span> <span class="pre">MNL</span></code> in the model configuration YAML file or omit the setting</li>
<li>call either <code class="docutils literal"><span class="pre">simulate.simple_simulate()</span></code> or <code class="docutils literal"><span class="pre">simulate.interaction_simulate()</span></code> depending if the alternatives are interacted with the choosers or because alternatives are sampled</li>
</ul>
<p>To specify and solve an NL model:</p>
<ul class="simple">
<li>specify <code class="docutils literal"><span class="pre">LOGIT_TYPE:</span> <span class="pre">NL</span></code> in the model configuration YAML file</li>
<li>specify the nesting structure via the NESTS setting in the model configuration YAML file.  An example nested logit NESTS entry can be found in <code class="docutils literal"><span class="pre">example/configs/tour_mode_choice.yaml</span></code></li>
<li>call <code class="docutils literal"><span class="pre">simulate.simple_simulate()</span></code>.  The <code class="docutils literal"><span class="pre">simulate.interaction_simulate()</span></code> functionality is not yet supported for NL.</li>
</ul>
<div class="section" id="id2">
<h3>API<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-activitysim.core.logit"></span><dl class="class">
<dt id="activitysim.core.logit.Nest">
<em class="property">class </em><code class="descclassname">activitysim.core.logit.</code><code class="descname">Nest</code><span class="sig-paren">(</span><em>name=None</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.logit.Nest" title="Permalink to this definition">¶</a></dt>
<dd><p>Data for a nest-logit node or leaf</p>
<p>This object is passed on yield when iterate over nest nodes (branch or leaf)
The nested logit design is stored in a yaml file as a tree of dict objects,
but using an object to pass the nest data makes the code a little more readable</p>
<p>An example nest specification is in the example tour mode choice model
yaml configuration file - example/configs/tour_mode_choice.yaml.</p>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.logit.each_nest">
<code class="descclassname">activitysim.core.logit.</code><code class="descname">each_nest</code><span class="sig-paren">(</span><em>nest_spec</em>, <em>type=None</em>, <em>post_order=False</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.logit.each_nest" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over each nest or leaf node in the tree (of subtree)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>nest_spec</strong> : dict</p>
<blockquote>
<div><p>Nest tree dict from the model spec yaml file</p>
</div></blockquote>
<p><strong>type</strong> : str</p>
<blockquote>
<div><p>Nest class type to yield
None yields all nests
‘leaf’ yields only leaf nodes
‘branch’ yields only branch nodes</p>
</div></blockquote>
<p><strong>post_order</strong> : Bool</p>
<blockquote>
<div><p>Should we iterate over the nodes of the tree in post-order or pre-order?
(post-order means we yield the alternatives sub-tree before current node.)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><p class="first"><strong>nest</strong> : Nest</p>
<blockquote class="last">
<div><p>Nest object with info about the current node (nest or leaf)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.logit.interaction_dataset">
<code class="descclassname">activitysim.core.logit.</code><code class="descname">interaction_dataset</code><span class="sig-paren">(</span><em>choosers</em>, <em>alternatives</em>, <em>sample_size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.logit.interaction_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine choosers and alternatives into one table for the purposes
of creating interaction variables and/or sampling alternatives.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>choosers</strong> : pandas.DataFrame</p>
<p><strong>alternatives</strong> : pandas.DataFrame</p>
<p><strong>sample_size</strong> : int, optional</p>
<blockquote>
<div><p>If sampling from alternatives for each chooser, this is
how many to sample.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>interacted</strong> : pandas.DataFrame</p>
<blockquote class="last">
<div><p>Merged choosers and alternatives with data repeated either
len(alternatives) or <cite>sample_size</cite> times.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.logit.make_choices">
<code class="descclassname">activitysim.core.logit.</code><code class="descname">make_choices</code><span class="sig-paren">(</span><em>probs</em>, <em>trace_label=None</em>, <em>trace_choosers=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.logit.make_choices" title="Permalink to this definition">¶</a></dt>
<dd><p>Make choices for each chooser from among a set of alternatives.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>probs</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>Rows for choosers and columns for the alternatives from which they
are choosing. Values are expected to be valid probabilities across
each row, e.g. they should sum to 1.</p>
</div></blockquote>
<p><strong>trace_choosers</strong> : pandas.dataframe</p>
<blockquote>
<div><p>the choosers df (for interaction_simulate) to facilitate the reporting of hh_id
by report_bad_choices because it can’t deduce hh_id from the interaction_dataset
which is indexed on index values from alternatives df</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>choices</strong> : pandas.Series</p>
<blockquote class="last">
<div><p>Maps chooser IDs (from <cite>probs</cite> index) to a choice, where the choice
is an index into the columns of <cite>probs</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.logit.report_bad_choices">
<code class="descclassname">activitysim.core.logit.</code><code class="descname">report_bad_choices</code><span class="sig-paren">(</span><em>bad_row_map</em>, <em>df</em>, <em>trace_label</em>, <em>msg</em>, <em>trace_choosers=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.logit.report_bad_choices" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>bad_row_map</strong></p>
<p><strong>df</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>utils or probs dataframe</p>
</div></blockquote>
<p><strong>msg</strong> : str</p>
<blockquote>
<div><p>message describing the type of bad choice that necessitates error being thrown</p>
</div></blockquote>
<p><strong>trace_choosers</strong> : pandas.dataframe</p>
<blockquote>
<div><p>the choosers df (for interaction_simulate) to facilitate the reporting of hh_id
because we  can’t deduce hh_id from the interaction_dataset which is indexed on index
values from alternatives df</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">raises RuntimeError</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.logit.utils_to_probs">
<code class="descclassname">activitysim.core.logit.</code><code class="descname">utils_to_probs</code><span class="sig-paren">(</span><em>utils</em>, <em>trace_label=None</em>, <em>exponentiated=False</em>, <em>allow_zero_probs=False</em>, <em>trace_choosers=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.logit.utils_to_probs" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a table of utilities to probabilities.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>utils</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>Rows should be choosers and columns should be alternatives.</p>
</div></blockquote>
<p><strong>trace_label</strong> : str</p>
<blockquote>
<div><p>label for tracing bad utility or probability values</p>
</div></blockquote>
<p><strong>exponentiated</strong> : bool</p>
<blockquote>
<div><p>True if utilities have already been exponentiated</p>
</div></blockquote>
<p><strong>allow_zero_probs</strong> : bool</p>
<blockquote>
<div><p>if True value rows in which all utility alts are EXP_UTIL_MIN will result
in rows in probs to have all zero probability (and not sum to 1.0)
This si for hte benefit of calculating probabilities of nested logit nests</p>
</div></blockquote>
<p><strong>trace_choosers</strong> : pandas.dataframe</p>
<blockquote>
<div><p>the choosers df (for interaction_simulate) to facilitate the reporting of hh_id
by report_bad_choices because it can’t deduce hh_id from the interaction_dataset
which is indexed on index values from alternatives df</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>probs</strong> : pandas.DataFrame</p>
<blockquote class="last">
<div><p>Will have the same index and columns as <cite>utils</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="pipeline">
<span id="pipeline-in-detail"></span><h2>Pipeline<a class="headerlink" href="#pipeline" title="Permalink to this headline">¶</a></h2>
<p>Data pipeline manager, which manages the list of model steps, runs them via orca, reads
and writes data tables from/to the pipeline datastore, and supports restarting of the pipeline
at any model step.</p>
<div class="section" id="id3">
<h3>API<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-activitysim.core.pipeline"></span><dl class="function">
<dt id="activitysim.core.pipeline.add_checkpoint">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">add_checkpoint</code><span class="sig-paren">(</span><em>checkpoint_name</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.add_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new checkpoint with specified name, write all data required to restore the simulation
to its current state.</p>
<p>Detect any changed tables , re-wrap them and write the current version to the pipeline store.
Write the current state of the random number generator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>checkpoint_name</strong> : str</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.checkpointed_tables">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">checkpointed_tables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.checkpointed_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the names of all checkpointed tables</p>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.close">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.close" title="Permalink to this definition">¶</a></dt>
<dd><p>Close any known open files</p>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.get_checkpoints">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">get_checkpoints</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.get_checkpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Get pandas dataframe of info about all checkpoints stored in pipeline</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>checkpoints_df</strong> : pandas.DataFrame</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.get_pipeline_store">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">get_pipeline_store</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.get_pipeline_store" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the open pipeline hdf5 checkpoint store or return False if it not been opened</p>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.get_rn_generator">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">get_rn_generator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.get_rn_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the singleton random number object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">activitysim.random.Random</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.get_table">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">get_table</code><span class="sig-paren">(</span><em>table_name</em>, <em>checkpoint_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.get_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pandas dataframe corresponding to table_name</p>
<p>if checkpoint_name is None, return the current (most recent) version of the table.
The table can be a checkpointed table or any registered orca table (e.g. function table)</p>
<p>if checkpoint_name is specified, return table as it was at that checkpoint
(the most recently checkpointed version of the table at or before checkpoint_name)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>table_name</strong> : str</p>
<p><strong>checkpoint_name</strong> : str or None</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>df</strong> : pandas.DataFrame</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.load_checkpoint">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">load_checkpoint</code><span class="sig-paren">(</span><em>checkpoint_name</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.load_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Load dataframes and restore random number channel state from pipeline hdf5 file.
This restores the pipeline state that existed at the specified checkpoint in a prior simulation.
This allows us to resume the simulation after the specified checkpoint</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>checkpoint_name</strong> : str</p>
<blockquote class="last">
<div><p>model_name of checkpoint to load (resume_after argument to start_pipeline)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.open_pipeline_store">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">open_pipeline_store</code><span class="sig-paren">(</span><em>overwrite=False</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.open_pipeline_store" title="Permalink to this definition">¶</a></dt>
<dd><p>Open the pipeline checkpoint store and add an orca injectable to access it</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>overwrite</strong> : bool</p>
<blockquote class="last">
<div><p>delete file before opening (unless resuming)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.orca_dataframe_tables">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">orca_dataframe_tables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.orca_dataframe_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the neames of all currently registered dataframe tables</p>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.read_df">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">read_df</code><span class="sig-paren">(</span><em>table_name</em>, <em>checkpoint_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.read_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a pandas dataframe from the pipeline store.</p>
<p>We store multiple versions of all simulation tables, for every checkpoint in which they change,
so we need to know both the table_name and the checkpoint_name of hte desired table.</p>
<p>The only exception is the checkpoints dataframe, which just has a table_name</p>
<p>An error will be raised by HDFStore if the table is not found</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>table_name</strong> : str</p>
<p><strong>checkpoint_name</strong> : str</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>df</strong> : pandas.DataFrame</p>
<blockquote class="last">
<div><p>the dataframe read from the store</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.rewrap">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">rewrap</code><span class="sig-paren">(</span><em>table_name</em>, <em>df=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.rewrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Add or replace an orca registered table as a unitary DataFrame-backed DataFrameWrapper table</p>
<p>if df is None, then get the dataframe from orca (table_name should be registered, or
an error will be thrown) which may involve evaluating added columns, etc.</p>
<p>If the orca table already exists, deregister it along with any associated columns before
re-registering it.</p>
<p>The net result is that the dataframe is a registered orca DataFrameWrapper table with no
computed or added columns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>table_name</strong></p>
<p><strong>df</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the underlying df of the rewrapped table</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.run">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">run</code><span class="sig-paren">(</span><em>models</em>, <em>resume_after=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.run" title="Permalink to this definition">¶</a></dt>
<dd><p>run the specified list of models, optionally loading checkpoint and resuming after specified
checkpoint.</p>
<p>Since we use model_name as checkpoint name, the same model may not be run more than once.</p>
<p>If resume_after checkpoint is specified and a model with that name appears in the models list,
then we only run the models after that point in the list. This allows the user always to pass
the same list of models, but specify a resume_after point if desired.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>models</strong> : [str]</p>
<blockquote>
<div><p>list of model_names</p>
</div></blockquote>
<p><strong>resume_after</strong> : str or None</p>
<blockquote class="last">
<div><p>model_name of checkpoint to load checkpoint and AFTER WHICH to resume model run</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.run_model">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">run_model</code><span class="sig-paren">(</span><em>model_name</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.run_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the specified model and add checkpoint for model_name</p>
<p>Since we use model_name as checkpoint name, the same model may not be run more than once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model_name</strong> : str</p>
<blockquote class="last">
<div><p>model_name is assumed to be the name of a registered orca step</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.set_rn_generator_base_seed">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">set_rn_generator_base_seed</code><span class="sig-paren">(</span><em>seed</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.set_rn_generator_base_seed" title="Permalink to this definition">¶</a></dt>
<dd><p>Like seed for numpy.random.RandomState, but generalized for use with all random streams.</p>
<p>Provide a base seed that will be added to the seeds of all random streams.
The default base seed value is 0, so set_base_seed(0) is a NOP</p>
<p>set_rn_generator_base_seed(1) will (e.g.) provide a different set of random streams
than the default, but will provide repeatable results re-running or resuming the simulation</p>
<p>set_rn_generator_base_seed(None) will set the base seed to a random and unpredictable integer
and so provides “fully pseudo random” non-repeatable streams with different results every time</p>
<p>Must be called before start_pipeline() or pipeline.run()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>seed</strong> : int or None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.start_pipeline">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">start_pipeline</code><span class="sig-paren">(</span><em>resume_after=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.start_pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Start pipeline, either for a new run or, if resume_after, loading checkpoint from pipeline.</p>
<p>If resume_after, then we expect the pipeline hdf5 file to exist and contain
checkpoints from a previous run, including a checkpoint with name specified in resume_after</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>resume_after</strong> : str or None</p>
<blockquote class="last">
<div><p>name of checkpoint to load from pipeline store</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.write_df">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">write_df</code><span class="sig-paren">(</span><em>df</em>, <em>table_name</em>, <em>checkpoint_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.write_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a pandas dataframe to the pipeline store.</p>
<p>We store multiple versions of all simulation tables, for every checkpoint in which they change,
so we need to know both the table_name and the checkpoint_name to label the saved table</p>
<p>The only exception is the checkpoints dataframe, which just has a table_name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>df</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>dataframe to store</p>
</div></blockquote>
<p><strong>table_name</strong> : str</p>
<blockquote>
<div><p>also conventionally the orca table name</p>
</div></blockquote>
<p><strong>checkpoint_name</strong> : str</p>
<blockquote class="last">
<div><p>the checkpoint at which the table was created/modified</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="random">
<span id="random-in-detail"></span><h2>Random<a class="headerlink" href="#random" title="Permalink to this headline">¶</a></h2>
<p>ActivitySim’s random number generation has a number of important features unique to AB modeling:</p>
<ul class="simple">
<li>Regression testing, debugging - run the exact model with the same inputs and get exactly the same results.</li>
<li>Debugging models - run the exact model with the same inputs but with changes to expression files and get the same results except where the equations differ.</li>
<li>Since runs can take a while, the above cases need to work with a restartable pipeline.</li>
<li>Debugging Multithreading - run the exact model with different multithreading configurations and get the same results.</li>
<li>Repeatable household-level choices - results for a household are repeatable when run with different sample sizes</li>
<li>Repeatable household level results with different scenarios - results for a household are repeatable with different scenario configurations sequentially up to the point at which those differences emerge, and in alternate submodels in which those differences do not apply.</li>
</ul>
<p>Random number generation is done using the <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html">numpy Mersenne Twister PNRG</a>.
ActivitySim seeds on-the-fly and uses a stream of random numbers seeded by the household id, person id, tour id, trip id, the model step offset, and the global seed.
The equation for calculating the seed looks something along the lines of:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">chooser_table</span><span class="o">.</span><span class="n">index</span> <span class="o">*</span> <span class="n">number_of_models_for_chooser</span> <span class="o">+</span> <span class="n">chooser_model_offset</span> <span class="o">+</span> <span class="n">global_seed_offset</span>

<span class="k">for</span> <span class="n">example</span>
  <span class="mi">1425</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">where</span><span class="p">:</span>
  <span class="mi">1425</span> <span class="o">=</span> <span class="n">household</span> <span class="n">table</span> <span class="n">index</span> <span class="o">-</span> <span class="n">households</span><span class="o">.</span><span class="n">id</span>
  <span class="mi">2</span> <span class="o">=</span> <span class="n">number</span> <span class="n">of</span> <span class="n">household</span> <span class="n">level</span> <span class="n">models</span> <span class="o">-</span> <span class="n">auto</span> <span class="n">ownership</span> <span class="ow">and</span> <span class="n">cdap</span>
  <span class="mi">0</span> <span class="o">=</span> <span class="n">first</span> <span class="n">household</span> <span class="n">model</span> <span class="o">-</span> <span class="n">auto</span> <span class="n">ownership</span>
  <span class="mi">1</span> <span class="o">=</span> <span class="k">global</span> <span class="n">seed</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">testing</span> <span class="n">the</span> <span class="n">same</span> <span class="n">model</span> <span class="n">under</span> <span class="n">different</span> <span class="n">random</span> <span class="k">global</span> <span class="n">seeds</span>
</pre></div>
</div>
<p>ActivitySim generates a separate, distinct, and stable random number stream for each tour type and tour number in order to maintain as much stability as is
possible across alternative scenarios.  This is done for trips as well, by direction (inbound versus outbound).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The Random module contains max model steps constants by chooser type - household, person, tour, trip - needs to be equal to the number of chooser sub-models.</p>
</div>
<div class="section" id="id4">
<h3>API<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-activitysim.core.random"></span><dl class="class">
<dt id="activitysim.core.random.SavedChannelState">
<em class="property">class </em><code class="descclassname">activitysim.core.random.</code><code class="descname">SavedChannelState</code><a class="headerlink" href="#activitysim.core.random.SavedChannelState" title="Permalink to this definition">¶</a></dt>
<dd><p>We expect that the random number channel can be determined by the name of the index of the
dataframe accompanying the request. This function encapsulates the knowledge of that mapping.</p>
<p>Generally, the channel name is just the table name used by the pipeline and orca.
The exception is the ‘tours’ channel, which is messy because the mandatory and non-mandatory
tours tables are originally created separately and later combined in to a single ‘tours’
table. But during a few model steps before they are combined, they actually exist as two
distinct tables. We only need to know this dirty secret about tables when we reload
checkpointed channels.</p>
<dl class="attribute">
<dt id="activitysim.core.random.SavedChannelState.channel_name">
<code class="descname">channel_name</code><a class="headerlink" href="#activitysim.core.random.SavedChannelState.channel_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 0</p>
</dd></dl>

<dl class="attribute">
<dt id="activitysim.core.random.SavedChannelState.step_name">
<code class="descname">step_name</code><a class="headerlink" href="#activitysim.core.random.SavedChannelState.step_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 2</p>
</dd></dl>

<dl class="attribute">
<dt id="activitysim.core.random.SavedChannelState.step_num">
<code class="descname">step_num</code><a class="headerlink" href="#activitysim.core.random.SavedChannelState.step_num" title="Permalink to this definition">¶</a></dt>
<dd><p>Alias for field number 1</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="activitysim.core.random.SimpleChannel">
<em class="property">class </em><code class="descclassname">activitysim.core.random.</code><code class="descname">SimpleChannel</code><span class="sig-paren">(</span><em>channel_name</em>, <em>base_seed</em>, <em>domain_df</em>, <em>max_steps</em>, <em>step_name</em>, <em>step_num</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.SimpleChannel" title="Permalink to this definition">¶</a></dt>
<dd><p>We need to ensure that we generate the same random streams (when re-run or even across
different simulations.) We do this by generating a random seed for each domain_df row
that is based on the domain_df index (which implies that generated tables like tours
and trips are also created with stable, predictable, repeatable row indexes.</p>
<p>Because we need to generate a distinct stream for each step, we can’t just use the
domain_df index - we need a strategy for handling multiple steps without generating
collisions between streams (i.e. choosing the same seed for more than one stream.)</p>
<p>The easiest way to do this would be to use an array of integers to seed the generator,
with a global seed, a channel seed, a row seed, and a step seed. Unfortunately, seeding
numpy RandomState with arrays is a LOT slower than with a single integer seed, and
speed matters because we reseed on-the-fly for every call because creating a different
RandomState object for each row uses too much memory (5K per RandomState object)</p>
<p>So instead, multiply the domain_df index by the number of steps required for the channel
add the step_num to the row_seed to get a unique seed for each (domain_df index, step_num)
tuple.</p>
<p>Currently, it is possible that random streams for rows in different tables may coincide.
This would be easy to avoid with either seed arrays or fast jump/offset.</p>
<p>numpy random seeds are unsigned int32 so there are 4,294,967,295 available seeds.
That is probably just about enough to distribute evenly, for most cities, depending on the
number of households, persons, tours, trips, and steps.</p>
<p>We do read in the whole households and persons tables at start time, so we could note the
max index values. But we might then want a way to ensure stability between the test, example,
and full datasets. I am punting on this for now.</p>
<dl class="method">
<dt id="activitysim.core.random.SimpleChannel.begin_step">
<code class="descname">begin_step</code><span class="sig-paren">(</span><em>step_name</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.SimpleChannel.begin_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset channel state for a new state</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>step_name</strong> : str</p>
<blockquote class="last">
<div><p>pipeline step name for this step</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.SimpleChannel.choice_for_df">
<code class="descname">choice_for_df</code><span class="sig-paren">(</span><em>df</em>, <em>step_name</em>, <em>a</em>, <em>size</em>, <em>replace</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.SimpleChannel.choice_for_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply numpy.random.choice once for each row in df
using the appropriate random channel for each row.</p>
<p>Concatenate the the choice arrays for every row into a single 1-D ndarray
The resulting array will be of length: size * len(df.index)
This method is designed to support creation of a interaction_dataset</p>
<p>The columns in df are ignored; the index name and values are used to determine
which random number sequence to to use.</p>
<p>We pass the multi_choice_offset to _generators_for_df as override_offset so that,
if multi_choice_offset has been set (by a call to set_multi_choice_offset method, q,v,)
_generators_for_df will EITHER use the same rand sequence for choosing values
OR use fresh random values for choices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>df</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>df with index name and values corresponding to a registered channel</p>
</div></blockquote>
<p><strong>step_name</strong> : str</p>
<blockquote>
<div><p>current step name so we can update row_states seed info</p>
</div></blockquote>
<p><strong>The remaining parameters are passed through as arguments to numpy.random.choice</strong></p>
<p><strong>a</strong> : 1-D array-like or int</p>
<blockquote>
<div><p>If an ndarray, a random sample is generated from its elements.
If an int, the random sample is generated as if a was np.arange(n)</p>
</div></blockquote>
<p><strong>size</strong> : int or tuple of ints</p>
<blockquote>
<div><p>Output shape</p>
</div></blockquote>
<p><strong>replace</strong> : boolean</p>
<blockquote>
<div><p>Whether the sample is with or without replacement</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>choices</strong> : 1-D ndarray of length: size * len(df.index)</p>
<blockquote class="last">
<div><p>The generated random samples for each row concatenated into a single (flat) array</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.SimpleChannel.create_row_states_for_domain">
<code class="descname">create_row_states_for_domain</code><span class="sig-paren">(</span><em>domain_df</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.SimpleChannel.create_row_states_for_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a dataframe with same index as domain_df and a single column
with stable, predictable, repeatable row_seeds for that domain_df index value</p>
<p>See notes on the seed generation strategy in class comment above.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>domain_df</strong> : pandas.dataframe</p>
<blockquote>
<div><p>domain dataframe with index values for which random streams are to be generated</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>row_states</strong> : pandas.DataFrame</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.SimpleChannel.extend_domain">
<code class="descname">extend_domain</code><span class="sig-paren">(</span><em>domain_df</em>, <em>step_name=None</em>, <em>step_num=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.SimpleChannel.extend_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Extend existing row_state df by addiing seed info for each row in domain_df</p>
<p>This is only needed if the channel is composed of more than one underlying table.
It is assumed that the index values of the component tables are disjoint and
there will be no ambiguity/collisions between them</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>domain_df</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>domain dataframe with index values for which random streams are to be generated
and well-known index name corresponding to the channel</p>
</div></blockquote>
<p><strong>step_name</strong> : str or None</p>
<blockquote>
<div><p>provided when reloading so we can restore step_name and step_num</p>
</div></blockquote>
<p class="last"><strong>step_num</strong> : int or None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.SimpleChannel.random_for_df">
<code class="descname">random_for_df</code><span class="sig-paren">(</span><em>df</em>, <em>step_name</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.SimpleChannel.random_for_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a single floating point random number in range [0, 1) for each row in df
using the appropriate random channel for each row.</p>
<p>Subsequent calls (in the same step) will return the next rand for each df row</p>
<p>The resulting array will be the same length (and order) as df
This method is designed to support alternative selection from a probability array</p>
<p>The columns in df are ignored; the index name and values are used to determine
which random number sequence to to use.</p>
<p>If “true pseudo random” behavior is desired (i.e. NOT repeatable) the set_base_seed
method (q.v.) may be used to globally reseed all random streams.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>df</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>df with index name and values corresponding to a registered channel</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>choices</strong> : 1-D ndarray the same length as df</p>
<blockquote class="last">
<div><p>a single float in range [0, 1) for each row in df</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.SimpleChannel.set_multi_choice_offset">
<code class="descname">set_multi_choice_offset</code><span class="sig-paren">(</span><em>offset</em>, <em>step_name</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.SimpleChannel.set_multi_choice_offset" title="Permalink to this definition">¶</a></dt>
<dd><p>setting multi_choice_offset ensures that multiple calls for the same row_state will yield
the same choices (assuming that choice array is the same length). It also permits avoiding
collisions with the rand() stream if multi_choice_offset is an integer larger than the
max number of random_for_df calls made in the same step.</p>
<p>choice_for_df passes multi_choice_offset to _generators_for_df as override_offset so that,
if multi_choice_offset has been set, _generators_for_df will
EITHER use the same rand sequence for choosing values
OR use fresh random values for choices.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>offset</strong> : int</p>
<blockquote>
<div><p>the offset into the current step’s random number stream at which to begin taking
rands for each choice_for_df row_state row</p>
</div></blockquote>
<p><strong>step_name</strong> : str</p>
<blockquote class="last">
<div><p>this allows us to ensure that this method is only ever called BEFORE the step begins</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="tracing">
<h2>Tracing<a class="headerlink" href="#tracing" title="Permalink to this headline">¶</a></h2>
<p>Household tracer.  If a household trace ID is specified, then ActivitySim will output a
comprehensive set of trace files for all calculations for all household members:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">hhtrace.log</span></code> - household trace log file, which specifies the CSV files traced. The order of output files is consistent with the model sequence.</li>
<li><code class="docutils literal"><span class="pre">various</span> <span class="pre">CSV</span> <span class="pre">files</span></code> - every input, intermediate, and output data table - chooser, expressions/utilities, probabilities, choices, etc. - for the trace household for every sub-model</li>
</ul>
<p>With the set of output CSV files, the user can trace ActivitySim’s calculations in order to ensure they are correct and/or to
help debug data and/or logic errors.</p>
<div class="section" id="id5">
<h3>API<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-activitysim.core.tracing"></span><dl class="function">
<dt id="activitysim.core.tracing.config_logger">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">config_logger</code><span class="sig-paren">(</span><em>custom_config_file=None</em>, <em>basic=False</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.config_logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure logger</p>
<p>if log_config_file is not supplied then look for conf file in configs_dir</p>
<p>if not found use basicConfig</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>custom_config_file: str</strong></p>
<blockquote>
<div><p>custom config filename</p>
</div></blockquote>
<p><strong>basic: boolean</strong></p>
<blockquote>
<div><p>basic setup</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Nothing</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.delete_csv_files">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">delete_csv_files</code><span class="sig-paren">(</span><em>output_dir</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.delete_csv_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete CSV files</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>output_dir: str</strong></p>
<blockquote>
<div><p>Directory of trace output CSVs</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Nothing</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.get_trace_target">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">get_trace_target</code><span class="sig-paren">(</span><em>df</em>, <em>slicer</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.get_trace_target" title="Permalink to this definition">¶</a></dt>
<dd><p>get target ids and column or index to identify target trace rows in df</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>df: pandas.DataFrame</strong></p>
<blockquote>
<div><p>dataframe to slice</p>
</div></blockquote>
<p><strong>slicer: str</strong></p>
<blockquote>
<div><p>name of column or index to use for slicing</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">(target, column) tuple</p>
<p><strong>target</strong> : int or list of ints</p>
<blockquote>
<div><p>id or ids that identify tracer target rows</p>
</div></blockquote>
<p><strong>column</strong> : str</p>
<blockquote class="last">
<div><p>name of column to search for targets or None to search index</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.interaction_trace_rows">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">interaction_trace_rows</code><span class="sig-paren">(</span><em>interaction_df</em>, <em>choosers</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.interaction_trace_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Trace model design for interaction_simulate</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>model_design: pandas.DataFrame</strong></p>
<blockquote>
<div><p>traced model_design dataframe</p>
</div></blockquote>
<p><strong>choosers: pandas.DataFrame</strong></p>
<blockquote>
<div><p>interaction_simulate choosers
(needed to filter the model_design dataframe by traced hh or person id)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>trace_rows</strong> : numpy.ndarray</p>
<blockquote>
<div><p>array of booleans to select values in eval_interaction_utilities df to trace</p>
</div></blockquote>
<p><strong>trace_ids</strong> : tuple (str,  numpy.ndarray)</p>
<blockquote class="last">
<div><p>column name and array of trace_ids for use by</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.log_file_path">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">log_file_path</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.log_file_path" title="Permalink to this definition">¶</a></dt>
<dd><p>For use in logging.yaml tag to inject log file path</p>
<p>filename: !!python/object/apply:activitysim.defaults.tracing.log_file_path [‘asim.log’]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>name: str</strong></p>
<blockquote>
<div><p>output folder name</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">f: str</p>
<blockquote class="last">
<div><p>output folder name</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.print_summary">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">print_summary</code><span class="sig-paren">(</span><em>label</em>, <em>df</em>, <em>describe=False</em>, <em>value_counts=False</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.print_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Print summary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>label: str</strong></p>
<blockquote>
<div><p>tracer name</p>
</div></blockquote>
<p><strong>df: pandas.DataFrame</strong></p>
<blockquote>
<div><p>traced dataframe</p>
</div></blockquote>
<p><strong>describe: boolean</strong></p>
<blockquote>
<div><p>print describe?</p>
</div></blockquote>
<p><strong>value_counts: boolean</strong></p>
<blockquote>
<div><p>print value counts?</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Nothing</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.register_households">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">register_households</code><span class="sig-paren">(</span><em>df</em>, <em>trace_hh_id</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.register_households" title="Permalink to this definition">¶</a></dt>
<dd><p>Register with orca households for tracing</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>df: pandas.DataFrame</strong></p>
<blockquote>
<div><p>traced dataframe</p>
</div></blockquote>
<p><strong>trace_hh_id: int</strong></p>
<blockquote>
<div><p>household id we are tracing</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Nothing</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.register_persons">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">register_persons</code><span class="sig-paren">(</span><em>df</em>, <em>trace_hh_id</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.register_persons" title="Permalink to this definition">¶</a></dt>
<dd><p>Register with orca persons for tracing</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>df: pandas.DataFrame</strong></p>
<blockquote>
<div><p>traced dataframe</p>
</div></blockquote>
<p><strong>trace_hh_id: int</strong></p>
<blockquote>
<div><p>household id we are tracing</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Nothing</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.register_tours">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">register_tours</code><span class="sig-paren">(</span><em>df</em>, <em>trace_hh_id</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.register_tours" title="Permalink to this definition">¶</a></dt>
<dd><p>Register with orca persons for tracing</p>
<p>create an orca injectable ‘trace_tour_ids’ with a list of tour_ids in household we are tracing.
This allows us to slice by tour_id without requiring presence of person_id column</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>df: pandas.DataFrame</strong></p>
<blockquote>
<div><p>traced dataframe</p>
</div></blockquote>
<p><strong>trace_hh_id: int</strong></p>
<blockquote>
<div><p>household id we are tracing</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Nothing</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.register_traceable_table">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">register_traceable_table</code><span class="sig-paren">(</span><em>table_name</em>, <em>df</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.register_traceable_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Register traceable table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>df: pandas.DataFrame</strong></p>
<blockquote>
<div><p>traced dataframe</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Nothing</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.register_trips">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">register_trips</code><span class="sig-paren">(</span><em>df</em>, <em>trace_hh_id</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.register_trips" title="Permalink to this definition">¶</a></dt>
<dd><p>Register with orca persons for tracing</p>
<p>create an orca injectable ‘trace_tour_ids’ with a list of tour_ids in household we are tracing.
This allows us to slice by tour_id without requiring presence of person_id column</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>df: pandas.DataFrame</strong></p>
<blockquote>
<div><p>traced dataframe</p>
</div></blockquote>
<p><strong>trace_hh_id: int</strong></p>
<blockquote>
<div><p>household id we are tracin</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Nothing</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.slice_canonically">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">slice_canonically</code><span class="sig-paren">(</span><em>df</em>, <em>slicer</em>, <em>label</em>, <em>warn_if_empty=False</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.slice_canonically" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice dataframe by traced household or person id dataframe and write to CSV</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>df: pandas.DataFrame</strong></p>
<blockquote>
<div><p>dataframe to slice</p>
</div></blockquote>
<p><strong>slicer: str</strong></p>
<blockquote>
<div><p>name of column or index to use for slicing</p>
</div></blockquote>
<p><strong>label: str</strong></p>
<blockquote>
<div><p>tracer name - only used to report bad slicer</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">sliced subset of dataframe</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.slice_ids">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">slice_ids</code><span class="sig-paren">(</span><em>df</em>, <em>ids</em>, <em>column=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.slice_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>slice a dataframe to select only records with the specified ids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>df: pandas.DataFrame</strong></p>
<blockquote>
<div><p>traced dataframe</p>
</div></blockquote>
<p><strong>ids: int or list of ints</strong></p>
<blockquote>
<div><p>slice ids</p>
</div></blockquote>
<p><strong>column: str</strong></p>
<blockquote>
<div><p>column to slice (slice using index if None)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">df: pandas.DataFrame</p>
<blockquote class="last">
<div><p>sliced dataframe</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.trace_df">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">trace_df</code><span class="sig-paren">(</span><em>df</em>, <em>label</em>, <em>slicer=None</em>, <em>columns=None</em>, <em>index_label=None</em>, <em>column_labels=None</em>, <em>transpose=True</em>, <em>warn_if_empty=False</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.trace_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice dataframe by traced household or person id dataframe and write to CSV</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>df: pandas.DataFrame</strong></p>
<blockquote>
<div><p>traced dataframe</p>
</div></blockquote>
<p><strong>label: str</strong></p>
<blockquote>
<div><p>tracer name</p>
</div></blockquote>
<p><strong>slicer: Object</strong></p>
<blockquote>
<div><p>slicer for subsetting</p>
</div></blockquote>
<p><strong>columns: list</strong></p>
<blockquote>
<div><p>columns to write</p>
</div></blockquote>
<p><strong>index_label: str</strong></p>
<blockquote>
<div><p>index name</p>
</div></blockquote>
<p><strong>column_labels: [str, str]</strong></p>
<blockquote>
<div><p>labels for columns in csv</p>
</div></blockquote>
<p><strong>transpose: boolean</strong></p>
<blockquote>
<div><p>whether to transpose file for legibility</p>
</div></blockquote>
<p><strong>warn_if_empty: boolean</strong></p>
<blockquote>
<div><p>write warning if sliced df is empty</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Nothing</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.trace_interaction_eval_results">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">trace_interaction_eval_results</code><span class="sig-paren">(</span><em>trace_results</em>, <em>trace_ids</em>, <em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.trace_interaction_eval_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Trace model design eval results for interaction_simulate</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>trace_results: pandas.DataFrame</strong></p>
<blockquote>
<div><p>traced model_design dataframe</p>
</div></blockquote>
<p><strong>trace_ids: pandas.DataFrame</strong></p>
<p><strong>trace_ids</strong> : tuple (str,  numpy.ndarray)</p>
<blockquote>
<div><p>column name and array of trace_ids from interaction_trace_rows()
used to filter the trace_results dataframe by traced hh or person id</p>
</div></blockquote>
<p><strong>label: str</strong></p>
<blockquote>
<div><p>tracer name</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Nothing</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.write_csv">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">write_csv</code><span class="sig-paren">(</span><em>df</em>, <em>file_name</em>, <em>index_label=None</em>, <em>columns=None</em>, <em>column_labels=None</em>, <em>transpose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.write_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Print write_csv</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>df: pandas.DataFrame or pandas.Series</strong></p>
<blockquote>
<div><p>traced dataframe</p>
</div></blockquote>
<p><strong>file_name: str</strong></p>
<blockquote>
<div><p>output file name</p>
</div></blockquote>
<p><strong>index_label: str</strong></p>
<blockquote>
<div><p>index name</p>
</div></blockquote>
<p><strong>columns: list</strong></p>
<blockquote>
<div><p>columns to write</p>
</div></blockquote>
<p><strong>transpose: bool</strong></p>
<blockquote>
<div><p>whether to transpose dataframe (ignored for series)</p>
</div></blockquote>
<p><strong>Returns</strong></p>
<p><strong>——-</strong></p>
<p class="last"><strong>Nothing</strong></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="assign">
<h2>Assign<a class="headerlink" href="#assign" title="Permalink to this headline">¶</a></h2>
<p>Alternative version of the expression evaluators in <a class="reference internal" href="#module-activitysim.core.simulate" title="activitysim.core.simulate"><code class="xref py py-mod docutils literal"><span class="pre">activitysim.core.simulate</span></code></a> that supports temporary variable assignment.
This is used by the <a class="reference internal" href="models.html#activitysim.abm.models.accessibility.compute_accessibility" title="activitysim.abm.models.accessibility.compute_accessibility"><code class="xref py py-func docutils literal"><span class="pre">compute_accessibility()</span></code></a>  module.</p>
<div class="section" id="id6">
<h3>API<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-activitysim.core.assign"></span><dl class="function">
<dt id="activitysim.core.assign.assign_variables">
<code class="descclassname">activitysim.core.assign.</code><code class="descname">assign_variables</code><span class="sig-paren">(</span><em>assignment_expressions</em>, <em>df</em>, <em>locals_dict</em>, <em>df_alias=None</em>, <em>trace_rows=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.assign.assign_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a set of variable expressions from a spec in the context
of a given data table.</p>
<p>Expressions are evaluated using Python’s eval function.
Python expressions have access to variables in locals_d (and df being
accessible as variable df.) They also have access to previously assigned
targets as the assigned target name.</p>
<p>lowercase variables starting with underscore are temp variables (e.g. _local_var)
and not returned except in trace_restults</p>
<p>uppercase variables starting with underscore are temp variables (e.g. _LOCAL_SCALAR)
and not returned except in trace_assigned_locals
This is useful for defining general purpose local constants in expression file</p>
<p>Users should take care that expressions should result in
a Pandas Series (scalars will be automatically promoted to series.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>assignment_expressions</strong> : pandas.DataFrame of target assignment expressions</p>
<blockquote>
<div><p>target: target column names
expression: pandas or python expression to evaluate</p>
</div></blockquote>
<p><strong>df</strong> : pandas.DataFrame</p>
<p><strong>locals_d</strong> : Dict</p>
<blockquote>
<div><p>This is a dictionary of local variables that will be the environment
for an evaluation of “python” expression.</p>
</div></blockquote>
<p><strong>trace_rows: series or array of bools to use as mask to select target rows to trace</strong></p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>variables</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>Will have the index of <cite>df</cite> and columns named by target and containing
the result of evaluating expression</p>
</div></blockquote>
<p><strong>trace_df</strong> : pandas.DataFrame or None</p>
<blockquote class="last">
<div><p>a dataframe containing the eval result values for each assignment expression</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.assign.read_assignment_spec">
<code class="descclassname">activitysim.core.assign.</code><code class="descname">read_assignment_spec</code><span class="sig-paren">(</span><em>fname</em>, <em>description_name=’Description’</em>, <em>target_name=’Target’</em>, <em>expression_name=’Expression’</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.assign.read_assignment_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a CSV model specification into a Pandas DataFrame or Series.</p>
<p>The CSV is expected to have columns for component descriptions
targets, and expressions,</p>
<p>The CSV is required to have a header with column names. For example:</p>
<blockquote>
<div>Description,Target,Expression</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>fname</strong> : str</p>
<blockquote>
<div><p>Name of a CSV spec file.</p>
</div></blockquote>
<p><strong>description_name</strong> : str, optional</p>
<blockquote>
<div><p>Name of the column in <cite>fname</cite> that contains the component description.</p>
</div></blockquote>
<p><strong>target_name</strong> : str, optional</p>
<blockquote>
<div><p>Name of the column in <cite>fname</cite> that contains the component target.</p>
</div></blockquote>
<p><strong>expression_name</strong> : str, optional</p>
<blockquote>
<div><p>Name of the column in <cite>fname</cite> that contains the component expression.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>spec</strong> : pandas.DataFrame</p>
<blockquote class="last">
<div><p>dataframe with three columns: [‘description’ ‘target’ ‘expression’]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.assign.undupe_column_names">
<code class="descclassname">activitysim.core.assign.</code><code class="descname">undupe_column_names</code><span class="sig-paren">(</span><em>df</em>, <em>template=’{} ({})’</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.assign.undupe_column_names" title="Permalink to this definition">¶</a></dt>
<dd><p>rename df column names so there are no duplicates (in place)</p>
<p>e.g. if there are two columns named “dog”, the second column will be reformatted to “dog (2)”</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>df</strong> : pandas.DataFrame</p>
<blockquote>
<div><p>dataframe whose column names should be de-duplicated</p>
</div></blockquote>
<p><strong>template</strong> : template taking two arguments (old_name, int) to use to rename columns</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>df</strong> : pandas.DataFrame</p>
<blockquote class="last">
<div><p>dataframe that was renamed in place, for convenience in chaining</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h2>
<p>Vectorized helper functions</p>
<div class="section" id="id7">
<h3>API<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-activitysim.core.util"></span><dl class="function">
<dt id="activitysim.core.util.other_than">
<code class="descclassname">activitysim.core.util.</code><code class="descname">other_than</code><span class="sig-paren">(</span><em>groups</em>, <em>bools</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.util.other_than" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a Series that has booleans indicating the presence of
something- or someone-else with a certain property within a group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>groups</strong> : pandas.Series</p>
<blockquote>
<div><p>A column with the same index as <cite>bools</cite> that defines the grouping
of <cite>bools</cite>. The <cite>bools</cite> Series will be used to index <cite>groups</cite> and
then the grouped values will be counted.</p>
</div></blockquote>
<p><strong>bools</strong> : pandas.Series</p>
<blockquote>
<div><p>A boolean Series indicating where the property of interest is present.
Should have the same index as <cite>groups</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>others</strong> : pandas.Series</p>
<blockquote class="last">
<div><p>A boolean Series with the same index as <cite>groups</cite> and <cite>bools</cite>
indicating whether there is something- or something-else within
a group with some property (as indicated by <cite>bools</cite>).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.util.quick_loc_df">
<code class="descclassname">activitysim.core.util.</code><code class="descname">quick_loc_df</code><span class="sig-paren">(</span><em>loc_list</em>, <em>target_df</em>, <em>attribute</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.util.quick_loc_df" title="Permalink to this definition">¶</a></dt>
<dd><p>faster replacement for target_df.loc[loc_list][attribute]</p>
<p>pandas DataFrame.loc[] indexing doesn’t scale for large arrays (e.g. &gt; 1,000,000 elements)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>loc_list</strong> : list-like (numpy.ndarray, pandas.Int64Index, or pandas.Series)</p>
<p><strong>target_df</strong> : pandas.DataFrame containing column named attribute</p>
<p><strong>attribute</strong> : name of column from loc_list to return</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">pandas.Series</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.util.quick_loc_series">
<code class="descclassname">activitysim.core.util.</code><code class="descname">quick_loc_series</code><span class="sig-paren">(</span><em>loc_list</em>, <em>target_series</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.util.quick_loc_series" title="Permalink to this definition">¶</a></dt>
<dd><p>faster replacement for target_series.loc[loc_list]</p>
<p>pandas Series.loc[] indexing doesn’t scale for large arrays (e.g. &gt; 1,000,000 elements)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>loc_list</strong> : list-like (numpy.ndarray, pandas.Int64Index, or pandas.Series)</p>
<p><strong>target_series</strong> : pandas.Series</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">pandas.Series</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.util.reindex">
<code class="descclassname">activitysim.core.util.</code><code class="descname">reindex</code><span class="sig-paren">(</span><em>series1</em>, <em>series2</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.util.reindex" title="Permalink to this definition">¶</a></dt>
<dd><p>This reindexes the first series by the second series.  This is an extremely
common operation that does not appear to  be in Pandas at this time.
If anyone knows of an easier way to do this in Pandas, please inform the
UrbanSim developers.</p>
<p>The canonical example would be a parcel series which has an index which is
parcel_ids and a value which you want to fetch, let’s say it’s land_area.
Another dataset, let’s say of buildings has a series which indicate the
parcel_ids that the buildings are located on, but which does not have
land_area.  If you pass parcels.land_area as the first series and
buildings.parcel_id as the second series, this function returns a series
which is indexed by buildings and has land_area as values and can be
added to the buildings dataset.</p>
<p>In short, this is a join on to a different table using a foreign key
stored in the current table, but with only one attribute rather than
for a full dataset.</p>
<p>This is very similar to the pandas “loc” function or “reindex” function,
but neither of those functions return the series indexed on the current
table.  In both of those cases, the series would be indexed on the foreign
table and would require a second step to change the index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>series1, series2</strong> : pandas.Series</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>reindexed</strong> : pandas.Series</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="config">
<h2>Config<a class="headerlink" href="#config" title="Permalink to this headline">¶</a></h2>
<p>Helper functions for configuring a model run</p>
<div class="section" id="id8">
<h3>API<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-activitysim.core.config"></span><dl class="function">
<dt id="activitysim.core.config.get_logit_model_settings">
<code class="descclassname">activitysim.core.config.</code><code class="descname">get_logit_model_settings</code><span class="sig-paren">(</span><em>model_settings</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.config.get_logit_model_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Read nest spec (for nested logit) from model settings file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>nests</strong> : dict</p>
<blockquote>
<div><p>dictionary specifying nesting structure and nesting coefficients</p>
</div></blockquote>
<p><strong>constants</strong> : dict</p>
<blockquote class="last">
<div><p>dictionary of constants to add to locals for use by expressions in model spec</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.config.get_model_constants">
<code class="descclassname">activitysim.core.config.</code><code class="descname">get_model_constants</code><span class="sig-paren">(</span><em>model_settings</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.config.get_model_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Read constants from model settings file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>constants</strong> : dict</p>
<blockquote class="last">
<div><p>dictionary of constants to add to locals for use by expressions in model spec</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="inject-defaults">
<h2>Inject_Defaults<a class="headerlink" href="#inject-defaults" title="Permalink to this headline">¶</a></h2>
<p>Default file and folder settings</p>
<div class="section" id="id9">
<h3>API<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-activitysim.core.inject_defaults"></span><dl class="function">
<dt id="activitysim.core.inject_defaults.pipeline_path">
<code class="descclassname">activitysim.core.inject_defaults.</code><code class="descname">pipeline_path</code><span class="sig-paren">(</span><em>output_dir</em>, <em>settings</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.inject_defaults.pipeline_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Orca injectable to return the path to the pipeline hdf5 file based on output_dir and settings</p>
</dd></dl>

</div>
</div>
<div class="section" id="tests">
<h2>Tests<a class="headerlink" href="#tests" title="Permalink to this headline">¶</a></h2>
<p>See activitysim.core.tests</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="models.html" class="btn btn-neutral float-right" title="Models" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="dataschema.html" class="btn btn-neutral" title="Data Schema" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright contributing authors.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.3dev1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>