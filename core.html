

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Core Components &mdash; ActivitySim 0.9
 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Software Development" href="development.html" />
    <link rel="prev" title="How the System Works" href="howitworks.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> ActivitySim
          

          
          </a>

          
            
            
              <div class="version">
                0.9

              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="gettingstarted.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="abmexample.html">Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="models.html">Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="howitworks.html">How the System Works</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Core Components</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#multiprocessing">Multiprocessing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-activitysim.core.mp_tasks">API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#data-management">Data Management</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#skim">Skim</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#pipeline">Pipeline</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id2">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#random">Random</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id3">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tracing">Tracing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id4">API</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#utility-expressions">Utility Expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#conventions">Conventions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#example-expressions-file">Example Expressions File</a></li>
<li class="toctree-l3"><a class="reference internal" href="#sampling-with-interaction">Sampling with Interaction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id5">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#simulate">Simulate</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id7">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#simulate-with-interaction">Simulate with Interaction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id9">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#simulate-with-sampling-and-interaction">Simulate with Sampling and Interaction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id10">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#assign">Assign</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id11">API</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#choice-models">Choice Models</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#logit">Logit</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id12">API</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#person-time-windows">Person Time Windows</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id13">API</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#helpers">Helpers</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#chunk">Chunk</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id14">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#utilities">Utilities</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id15">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#config">Config</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id16">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#inject">Inject</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id18">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#mem">Mem</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id19">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#output">Output</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id20">API</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#tests">Tests</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="development.html">Software Development</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">ActivitySim</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Core Components</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/core.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="core-components">
<h1>Core Components<a class="headerlink" href="#core-components" title="Permalink to this headline">¶</a></h1>
<p>ActivitySim’s core components include features for multiprocessing, data management,
utility expressions, choice models, person time window management, and helper
functions.  These core components include the multiprocessor, skim matrix manager, the
data pipeline manager, the random number manager, the tracer, sampling
methods, simulation methods, model specification readers and expression
evaluators, choice models, timetable, and helper functions.</p>
<div class="section" id="multiprocessing">
<span id="multiprocessing-in-detail"></span><h2>Multiprocessing<a class="headerlink" href="#multiprocessing" title="Permalink to this headline">¶</a></h2>
<p>Parallelization using multiprocessing</p>
<div class="section" id="module-activitysim.core.mp_tasks">
<span id="api"></span><h3>API<a class="headerlink" href="#module-activitysim.core.mp_tasks" title="Permalink to this headline">¶</a></h3>
<dl class="data">
<dt id="activitysim.core.mp_tasks.LAST_CHECKPOINT">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">LAST_CHECKPOINT</code><em class="property"> = '_'</em><a class="headerlink" href="#activitysim.core.mp_tasks.LAST_CHECKPOINT" title="Permalink to this definition">¶</a></dt>
<dd><p>mp_tasks - activitysim multiprocessing overview</p>
<p>Activitysim runs a list of models sequentially, performing various computational operations
on tables. Model steps can modify values in existing tables, add columns, or create additional
tables. Activitysim provides the facility, via expression files, to specify vectorized operations
on data tables. The ability to vectorize operations depends upon the independence of the
computations performed on the vectorized elements.</p>
<p>Python is agonizingly slow performing scalar operations sequentially on large datasets, so
vectorization (using pandas and/or numpy) is essential for good performance.</p>
<p>Fortunately most activity based model simulation steps are row independent at the household,
person, tour, or trip level. The decisions for one household are independent of the choices
made by other households. Thus it is (generally speaking) possible to run an entire simulation
on a household sample with only one household, and get the same result for that household as
you would running the simulation on a thousand households. (See the shared data section below
for an exception to this highly convenient situation.)</p>
<p>The random number generator supports this goal by providing streams of random numbers
for each households and person that are mutually independent and repeatable across model runs
and processes.</p>
<p>To the extent that simulation model steps are row independent, we can implement most simulations
as a series of vectorized operations on pandas DataFrames and numpy arrays. These vectorized
operations are much faster than sequential python because they are implemented by native code
(compiled C) and are to some extent multi-threaded. But the benefits of numpy multi-processing are
limited because they only apply to atomic numpy or pandas calls, and as soon as control returns
to python it is single-threaded and slow.</p>
<p>Multi-threading is not an attractive strategy to get around the python performance problem because
of the limitations imposed by python’s global interpreter lock (GIL). Rather than struggling with
python multi-threading, this module uses the python multiprocessing to parallelize certain models.</p>
<p>Because of activitysim’s modular and extensible architecture, we don’t hardwire the multiprocessing
architecture. The specification of which models should be run in parallel, how many processers
should be used, and the segmentation of the data between processes are all specified in the
settings config file. For conceptual simplicity, the single processing model as treated as
dominant (because even though in practice multiprocessing may be the norm for production runs,
the single-processing model will be used in development and debugging and keeping it dominant
will tend to concentrate the multiprocessing-specific code in one place and prevent multiprocessing
considerations from permeating the code base obscuring the model-specific logic.</p>
<p>The primary function of the multiprocessing settings are to identify distinct stages of
computation, and to specify how many simultaneous processes should be used to perform them,
and how the data to be treated should be apportioned between those processes. We assume that
the data can be apportioned between subprocesses according to the index of a single primary table
(e.g. households) or else are by derivative or dependent tables that reference that table’s index
(primary key) with a ref_col (foreign key) sharing the name of the primary table’s key.</p>
<p>Generally speaking, we assume that any new tables that are created are directly dependent on the
previously existing tables, and all rows in new tables are either attributable to previously
existing rows in the pipeline tables, or are global utility tables that are identical across
sub-processes.</p>
<p>Note: There are a few exceptions to ‘row independence’, such as school and location choice models,
where the model behavior is externally constrained or adjusted. For instance, we want school
location choice to match known aggregate school enrollments by zone. Similarly, a parking model
(not yet implemented) might be constrained by availability. These situations require special
handling.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">models</span><span class="p">:</span>
  <span class="c1">### mp_initialize step</span>
  <span class="o">-</span> <span class="n">initialize_landuse</span>
  <span class="o">-</span> <span class="n">compute_accessibility</span>
  <span class="o">-</span> <span class="n">initialize_households</span>
  <span class="c1">### mp_households step</span>
  <span class="o">-</span> <span class="n">school_location</span>
  <span class="o">-</span> <span class="n">workplace_location</span>
  <span class="o">-</span> <span class="n">auto_ownership_simulate</span>
  <span class="o">-</span> <span class="n">free_parking</span>
  <span class="c1">### mp_summarize step</span>
  <span class="o">-</span> <span class="n">write_tables</span>

<span class="n">multiprocess_steps</span><span class="p">:</span>
  <span class="o">-</span> <span class="n">name</span><span class="p">:</span> <span class="n">mp_initialize</span>
    <span class="n">begin</span><span class="p">:</span> <span class="n">initialize_landuse</span>
  <span class="o">-</span> <span class="n">name</span><span class="p">:</span> <span class="n">mp_households</span>
    <span class="n">begin</span><span class="p">:</span> <span class="n">school_location</span>
    <span class="n">num_processes</span><span class="p">:</span> <span class="mi">2</span>
    <span class="nb">slice</span><span class="p">:</span>
      <span class="n">tables</span><span class="p">:</span>
        <span class="o">-</span> <span class="n">households</span>
        <span class="o">-</span> <span class="n">persons</span>
  <span class="o">-</span> <span class="n">name</span><span class="p">:</span> <span class="n">mp_summarize</span>
    <span class="n">begin</span><span class="p">:</span> <span class="n">write_tables</span>
</pre></div>
</div>
<p>The multiprocess_steps setting above annotates the models list to indicate that the simulation
should be broken into three steps.</p>
<p>The first multiprocess_step (mp_initialize) begins with the initialize_landuse step and is
implicity single-process because there is no ‘slice’ key indicating how to apportion the tables.
This first step includes all models listed in the ‘models’ setting up until the first step
in the next multiprocess_steps.</p>
<p>The second multiprocess_step (mp_households) starts with the school location model and continues
through auto_ownership_simulate. The ‘slice’ info indicates that the tables should be sliced by
households, and that persons is a dependent table and so and persons with a ref_col (foreign key
column with the same name as the Households table index) referencing a household record should be
taken to ‘belong’ to that household. Similarly, any other table that either share an index
(i.e. having the same name) with either the households or persons table, or have a ref_col to
either of their indexes, should also be considered a dependent table.</p>
<p>The num_processes setting of 2 indicates that the pipeline should be split in two, and half of the
households should be apportioned into each subprocess pipeline, and all dependent tables should
likewise be apportioned accordingly. All other tables (e.g. land_use) that do share an index (name)
or have a ref_col should be considered mirrored and be included in their entirety.</p>
<p>The primary table is sliced by num_processes-sized strides. (e.g. for num_processes == 2, the
sub-processes get every second record starting at offsets 0 and 1 respectively. All other dependent
tables slices are based (directly or indirectly) on this primary stride segmentation of the primary
table index.</p>
<p>Two separate sub-process are launched (num_processes == 2) and each passed the name of their
apportioned pipeline file. They execute independently and if they terminate successfully, their
contents are then coalesced into a single pipeline file whose tables should then be essentially
the same as it had been generated by a single process.</p>
<p>We assume that any new tables that are created by the sub-processes are directly dependent on the
previously primary tables or are mirrored. Thus we can coalesce the sub-process pipelines by
concatenating the primary and dependent tables and simply retaining any copy of the mirrored tables
(since they should all be identical.)</p>
<p>The third multiprocess_step (mp_summarize) then is handled in single-process mode and runs the
write_tables model, writing the results, but also leaving the tables in the pipeline, with
essentially the same tables and results as if the whole simulation had been run as a single process.</p>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.allocate_shared_shadow_pricing_buffers">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">allocate_shared_shadow_pricing_buffers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.allocate_shared_shadow_pricing_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>This is called by the main process and allocate memory buffer to share with subprocs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>multiprocessing.RawArray</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.allocate_shared_skim_buffers">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">allocate_shared_skim_buffers</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.allocate_shared_skim_buffers" title="Permalink to this definition">¶</a></dt>
<dd><p>This is called by the main process to allocate shared memory buffer to share with subprocs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>skim_buffers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict {&lt;block_name&gt;: &lt;multiprocessing.RawArray&gt;}</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.apportion_pipeline">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">apportion_pipeline</code><span class="sig-paren">(</span><em>sub_proc_names</em>, <em>slice_info</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.apportion_pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>apportion pipeline for multiprocessing step</p>
<p>create pipeline files for sub_procs, apportioning data based on slice_rules</p>
<p>Called at the beginning of a multiprocess step prior to launching the sub-processes
Pipeline files have well known names (pipeline file name prefixed by subjob name)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sub_proc_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">names of the sub processes to apportion</p>
</dd>
<dt><strong>slice_info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">slice_info from multiprocess_steps</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>creates apportioned pipeline files for each sub job</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.build_slice_rules">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">build_slice_rules</code><span class="sig-paren">(</span><em>slice_info</em>, <em>pipeline_tables</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.build_slice_rules" title="Permalink to this definition">¶</a></dt>
<dd><p>based on slice_info for current step from run_list, generate a recipe for slicing
the tables in the pipeline (passed in tables parameter)</p>
<dl class="docutils">
<dt>slice_info is a dict with two well-known keys:</dt>
<dd>‘tables’: required list of table names (order matters!)
‘except’: optional list of tables not to slice even if they have a sliceable index name</dd>
</dl>
<p>Note: tables listed in slice_info must appear in same order and before any others in tables dict</p>
<p>The index of the first table in the ‘tables’ list is the primary_slicer. Subsequent tables
are dependent (have a column with the sae</p>
<p>Any other tables listed ar dependent tables with either ref_cols to the primary_slicer
or with the same index (i.e. having an index with the same name). This cascades, so any
tables dependent on the primary_table can in turn have dependent tables that will be sliced
by index or ref_col.</p>
<p>For instance, if the primary_slicer is households, then persons can be sliced because it
has a ref_col to (column with the same same name as) the household table index. And the
tours table can be sliced since it has a ref_col to persons. Tables can also be sliced
by index. For instance the person_windows table can be sliced because it has an index with
the same names as the persons table.</p>
<p>slice_info from multiprocess_steps</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">slice</span><span class="p">:</span>
  <span class="n">tables</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">households</span>
    <span class="o">-</span> <span class="n">persons</span>
</pre></div>
</div>
<p>tables from pipeline</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="30%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Table Name</th>
<th class="head">Index</th>
<th class="head">ref_col</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>households</td>
<td>household_id</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>persons</td>
<td>person_id</td>
<td>household_id</td>
</tr>
<tr class="row-even"><td>person_windows</td>
<td>person_id</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>accessibility</td>
<td>zone_id</td>
<td>&#160;</td>
</tr>
</tbody>
</table>
<p>generated slice_rules dict</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">households</span><span class="p">:</span>
   <span class="n">slice_by</span><span class="p">:</span> <span class="n">primary</span>       <span class="o">&lt;-</span> <span class="n">primary</span> <span class="n">table</span> <span class="ow">is</span> <span class="n">sliced</span> <span class="ow">in</span> <span class="n">num_processors</span><span class="o">-</span><span class="n">sized</span> <span class="n">strides</span>
<span class="n">persons</span><span class="p">:</span>
   <span class="n">source</span><span class="p">:</span> <span class="n">households</span>
   <span class="n">slice_by</span><span class="p">:</span> <span class="n">column</span>
   <span class="n">column</span><span class="p">:</span>  <span class="n">household_id</span>   <span class="o">&lt;-</span> <span class="nb">slice</span> <span class="n">by</span> <span class="n">ref_col</span> <span class="p">(</span><span class="n">foreign</span> <span class="n">key</span><span class="p">)</span> <span class="n">to</span> <span class="n">households</span>
<span class="n">person_windows</span><span class="p">:</span>
   <span class="n">source</span><span class="p">:</span> <span class="n">persons</span>
   <span class="n">slice_by</span><span class="p">:</span> <span class="n">index</span>         <span class="o">&lt;-</span> <span class="nb">slice</span> <span class="n">by</span> <span class="n">index</span> <span class="n">of</span> <span class="n">persons</span> <span class="n">table</span>
<span class="n">accessibility</span><span class="p">:</span>
   <span class="n">slice_by</span><span class="p">:</span>               <span class="o">&lt;-</span> <span class="n">mirrored</span> <span class="p">(</span><span class="n">non</span><span class="o">-</span><span class="n">dependent</span><span class="p">)</span> <span class="n">tables</span> <span class="n">don</span><span class="s1">&#39;t get sliced</span>
<span class="n">land_use</span><span class="p">:</span>
   <span class="n">slice_by</span><span class="p">:</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>slice_info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">‘slice’ info from run_list for this step</p>
</dd>
<dt><strong>pipeline_tables</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict {&lt;table_name&gt;, &lt;pandas.DataFrame&gt;}</span></dt>
<dd><p class="first last">dict of all tables from the pipeline keyed by table name</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>slice_rules</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.coalesce_pipelines">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">coalesce_pipelines</code><span class="sig-paren">(</span><em>sub_proc_names</em>, <em>slice_info</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.coalesce_pipelines" title="Permalink to this definition">¶</a></dt>
<dd><p>Coalesce the data in the sub_processes apportioned pipelines back into a single pipeline</p>
<p>We use slice_rules to distinguish sliced (apportioned) tables from mirrored tables.</p>
<p>Sliced tables are concatenated to create a single omnibus table with data from all sub_procs
but mirrored tables are the same across all sub_procs, so we can grab a copy from any pipeline.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>sub_proc_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd></dd>
<dt><strong>slice_info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">slice_info from multiprocess_steps</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>creates an omnibus pipeline with coalesced data from individual sub_proc pipelines</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.drop_breadcrumb">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">drop_breadcrumb</code><span class="sig-paren">(</span><em>step_name</em>, <em>crumb</em>, <em>value=True</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.drop_breadcrumb" title="Permalink to this definition">¶</a></dt>
<dd><p>Add (crumb: value) to specified step in breadcrumbs and flush breadcrumbs to file
run can be resumed with resume_after</p>
<p>Breadcrumbs provides a record of steps that have been run for use when resuming
Basically, we want to know which steps have been run, which phases completed
(i.e. apportion, simulate, coalesce). For multi-processed simulate steps, we also
want to know which sub-processes completed successfully, because if resume_after
is LAST_CHECKPOINT we don’t have to rerun the successful ones.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>step_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd></dd>
<dt><strong>crumb</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd></dd>
<dt><strong>value</strong> <span class="classifier-delimiter">:</span> <span class="classifier">yaml-writable value</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.get_breadcrumbs">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">get_breadcrumbs</code><span class="sig-paren">(</span><em>run_list</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.get_breadcrumbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Read, validate, and annotate breadcrumb file from previous run</p>
<p>if resume_after specifies a model name, we need to determine which step it falls within,
drop any subsequent steps, and set the ‘simulate’ and ‘coalesce’ to None so</p>
<p>Extract from breadcrumbs file showing completed mp_households step with 2 processes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">apportion</span><span class="p">:</span> <span class="n">true</span>
  <span class="n">completed</span><span class="p">:</span> <span class="p">[</span><span class="n">mp_households_0</span><span class="p">,</span> <span class="n">mp_households_1</span><span class="p">]</span>
  <span class="n">name</span><span class="p">:</span> <span class="n">mp_households</span>
  <span class="n">simulate</span><span class="p">:</span> <span class="n">true</span>
  <span class="n">coalesce</span><span class="p">:</span> <span class="n">true</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>run_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">validated and annotated run_list from settings</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>breadcrumbs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">validated and annotated breadcrumbs file from previous run</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.get_run_list">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">get_run_list</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.get_run_list" title="Permalink to this definition">¶</a></dt>
<dd><p>validate and annotate run_list from settings</p>
<p>Assign defaults to missing settings (e.g. stagger, chunk_size)
Build individual step model lists based on step starts
If resuming, read breadcrumbs file for info on previous run execution status</p>
<p># annotated run_list with two steps, the second with 2 processors</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">resume_after</span><span class="p">:</span> <span class="kc">None</span>
<span class="n">multiprocess</span><span class="p">:</span> <span class="kc">True</span>
<span class="n">models</span><span class="p">:</span>
  <span class="o">-</span>  <span class="n">initialize_landuse</span>
  <span class="o">-</span>  <span class="n">compute_accessibility</span>
  <span class="o">-</span>  <span class="n">initialize_households</span>
  <span class="o">-</span>  <span class="n">school_location</span>
  <span class="o">-</span>  <span class="n">workplace_location</span>

<span class="n">multiprocess_steps</span><span class="p">:</span>
  <span class="n">step</span><span class="p">:</span> <span class="n">mp_initialize</span>
    <span class="n">begin</span><span class="p">:</span> <span class="n">initialize_landuse</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">mp_initialize</span>
    <span class="n">models</span><span class="p">:</span>
       <span class="o">-</span> <span class="n">initialize_landuse</span>
       <span class="o">-</span> <span class="n">compute_accessibility</span>
       <span class="o">-</span> <span class="n">initialize_households</span>
    <span class="n">num_processes</span><span class="p">:</span> <span class="mi">1</span>
    <span class="n">stagger</span><span class="p">:</span> <span class="mi">5</span>
    <span class="n">chunk_size</span><span class="p">:</span> <span class="mi">0</span>
    <span class="n">step_num</span><span class="p">:</span> <span class="mi">0</span>
  <span class="n">step</span><span class="p">:</span> <span class="n">mp_households</span>
    <span class="n">begin</span><span class="p">:</span> <span class="n">school_location</span>
    <span class="nb">slice</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;tables&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;households&#39;</span><span class="p">,</span> <span class="s1">&#39;persons&#39;</span><span class="p">]}</span>
    <span class="n">name</span><span class="p">:</span> <span class="n">mp_households</span>
    <span class="n">models</span><span class="p">:</span>
       <span class="o">-</span> <span class="n">school_location</span>
       <span class="o">-</span> <span class="n">workplace_location</span>
    <span class="n">num_processes</span><span class="p">:</span> <span class="mi">2</span>
    <span class="n">stagger</span><span class="p">:</span> <span class="mi">5</span>
    <span class="n">chunk_size</span><span class="p">:</span> <span class="mi">10000</span>
    <span class="n">step_num</span><span class="p">:</span> <span class="mi">1</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>run_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">validated and annotated run_list</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.if_sub_task">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">if_sub_task</code><span class="sig-paren">(</span><em>if_is</em>, <em>if_isnt</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.if_sub_task" title="Permalink to this definition">¶</a></dt>
<dd><p>select one of two values depending whether current process is primary process or subtask</p>
<p>This is primarily intended for use in yaml files to select between (e.g.) logging levels
so main log file can display only warnings and errors from subtasks</p>
<p>In yaml file, it can be used like this:</p>
<p>level: !!python/object/apply:activitysim.core.mp_tasks.if_sub_task [WARNING, NOTSET]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>if_is</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(any type) value to return if process is a subtask</span></dt>
<dd></dd>
<dt><strong>if_isnt</strong> <span class="classifier-delimiter">:</span> <span class="classifier">(any type) value to return if process is not a subtask</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>(any type) (one of parameters if_is or if_isnt)</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.mp_apportion_pipeline">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">mp_apportion_pipeline</code><span class="sig-paren">(</span><em>injectables</em>, <em>sub_proc_names</em>, <em>slice_info</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.mp_apportion_pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>mp entry point for apportion_pipeline</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>injectables</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">injectables from parent</p>
</dd>
<dt><strong>sub_proc_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">names of the sub processes to apportion</p>
</dd>
<dt><strong>slice_info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">slice_info from multiprocess_steps</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.mp_coalesce_pipelines">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">mp_coalesce_pipelines</code><span class="sig-paren">(</span><em>injectables</em>, <em>sub_proc_names</em>, <em>slice_info</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.mp_coalesce_pipelines" title="Permalink to this definition">¶</a></dt>
<dd><p>mp entry point for coalesce_pipeline</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>injectables</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">injectables from parent</p>
</dd>
<dt><strong>sub_proc_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">names of the sub processes to apportion</p>
</dd>
<dt><strong>slice_info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">slice_info from multiprocess_steps</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.mp_run_simulation">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">mp_run_simulation</code><span class="sig-paren">(</span><em>locutor</em>, <em>queue</em>, <em>injectables</em>, <em>step_info</em>, <em>resume_after</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.mp_run_simulation" title="Permalink to this definition">¶</a></dt>
<dd><p>mp entry point for run_simulation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>locutor</strong></dt>
<dd></dd>
<dt><strong>queue</strong></dt>
<dd></dd>
<dt><strong>injectables</strong></dt>
<dd></dd>
<dt><strong>step_info</strong></dt>
<dd></dd>
<dt><strong>resume_after</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd></dd>
<dt><strong>kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">shared_data_buffers passed as kwargs to avoid picking dict</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.mp_setup_skims">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">mp_setup_skims</code><span class="sig-paren">(</span><em>injectables</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.mp_setup_skims" title="Permalink to this definition">¶</a></dt>
<dd><p>Sub process to load skim data into shared_data</p>
<p>There is no particular necessity to perform this in a sub process instead of the parent
except to ensure that this heavyweight task has no side-effects (e.g. loading injectables)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>injectables</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">injectables from parent</p>
</dd>
<dt><strong>kwargs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">shared_data_buffers passed as kwargs to avoid picking dict</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.pipeline_table_keys">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">pipeline_table_keys</code><span class="sig-paren">(</span><em>pipeline_store</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.pipeline_table_keys" title="Permalink to this definition">¶</a></dt>
<dd><p>return dict of current (as of last checkpoint) pipeline tables
and their checkpoint-specific hdf5_keys</p>
<p>This facilitates reading pipeline tables directly from a ‘raw’ open pandas.HDFStore without
opening it as a pipeline (e.g. when apportioning and coalescing pipelines)</p>
<p>We currently only ever need to do this from the last checkpoint, so the ability to specify
checkpoint_name is not required, and thus omitted.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>pipeline_store</strong> <span class="classifier-delimiter">:</span> <span class="classifier">open hdf5 pipeline_store</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>checkpoint_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">name of the checkpoint</span></dt>
<dd></dd>
<dt><strong>checkpoint_tables</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict {&lt;table_name&gt;: &lt;table_key&gt;}</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.print_run_list">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">print_run_list</code><span class="sig-paren">(</span><em>run_list</em>, <em>output_file=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.print_run_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Print run_list to stdout or file (informational - not read back in)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>run_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd></dd>
<dt><strong>output_file</strong> <span class="classifier-delimiter">:</span> <span class="classifier">open file</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.read_breadcrumbs">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">read_breadcrumbs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.read_breadcrumbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Read breadcrumbs file from previous run</p>
<p>write_breadcrumbs wrote OrderedDict steps as list so ordered is preserved
(step names are duplicated in steps)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>breadcrumbs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">OrderedDict</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.run_multiprocess">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">run_multiprocess</code><span class="sig-paren">(</span><em>run_list</em>, <em>injectables</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.run_multiprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>run the steps in run_list, possibly resuming after checkpoint specified by resume_after</p>
<p>Steps may be either single or multi process.
For multi-process steps, we need to apportion pipelines before running sub processes
and coalesce them afterwards</p>
<p>injectables arg allows propagation of setting values that were overridden on the command line
(parent process command line arguments are not available to sub-processes in Windows)</p>
<ul class="simple">
<li>allocate shared data buffers for skims and shadow_pricing</li>
<li>load shared skim data from OMX files</li>
<li>run each (single or multiprocess) step in turn</li>
</ul>
<p>Drop breadcrumbs along the way to facilitate resuming in a later run</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>run_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">annotated run_list  (including prior run breadcrumbs if resuming)</p>
</dd>
<dt><strong>injectables</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">dict of values to inject in sub-processes</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.run_simulation">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">run_simulation</code><span class="sig-paren">(</span><em>queue</em>, <em>step_info</em>, <em>resume_after</em>, <em>shared_data_buffer</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.run_simulation" title="Permalink to this definition">¶</a></dt>
<dd><p>run step models as subtask</p>
<p>called once to run each individual sub process in multiprocess step</p>
<p>Unless actually resuming resuming, resume_after will be None for first step,
and then FINAL for subsequent steps so pipelines opened to resume where previous step left off</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>queue</strong> <span class="classifier-delimiter">:</span> <span class="classifier">multiprocessing.Queue</span></dt>
<dd></dd>
<dt><strong>step_info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">step_info for current step from multiprocess_steps</p>
</dd>
<dt><strong>resume_after</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span></dt>
<dd></dd>
<dt><strong>shared_data_buffer</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">dict of shared data (e.g. skims and shadow_pricing)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.run_sub_simulations">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">run_sub_simulations</code><span class="sig-paren">(</span><em>injectables</em>, <em>shared_data_buffers</em>, <em>step_info</em>, <em>process_names</em>, <em>resume_after</em>, <em>previously_completed</em>, <em>fail_fast</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.run_sub_simulations" title="Permalink to this definition">¶</a></dt>
<dd><p>Launch sub processes to run models in step according to specification in step_info.</p>
<p>If resume_after is LAST_CHECKPOINT, then pick up where previous run left off, using breadcrumbs
from previous run. If some sub-processes completed in the prior run, then skip rerunning them.</p>
<p>If resume_after specifies a checkpiont, skip checkpoints that precede the resume_after</p>
<p>Drop ‘completed’ breadcrumbs for this run as sub-processes terminate</p>
<p>Wait for all sub-processes to terminate and return list of those that completed successfully.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>injectables</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">values to inject in subprocesses</p>
</dd>
<dt><strong>shared_data_buffers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">dict of shared_data for sub-processes (e.g. skim and shadow pricing data)</p>
</dd>
<dt><strong>step_info</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">step_info from run_list</p>
</dd>
<dt><strong>process_names</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">list of sub process names to in parallel</p>
</dd>
<dt><strong>resume_after</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span></dt>
<dd><p class="first last">name of simulation to resume after, or LAST_CHECKPOINT to resume where previous run left off</p>
</dd>
<dt><strong>previously_completed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">names of processes that successfully completed in previous run</p>
</dd>
<dt><strong>fail_fast</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">whether to raise error if a sub process terminates with nonzero exitcode</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>completed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of str</span></dt>
<dd><p class="first last">names of sub_processes that completed successfully</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.run_sub_task">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">run_sub_task</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.run_sub_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Run process p synchroneously,</p>
<p>Return when sub process terminates, or raise error if exitcode is nonzero</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>p</strong> <span class="classifier-delimiter">:</span> <span class="classifier">multiprocessing.Process</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.setup_injectables_and_logging">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">setup_injectables_and_logging</code><span class="sig-paren">(</span><em>injectables</em>, <em>locutor=True</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.setup_injectables_and_logging" title="Permalink to this definition">¶</a></dt>
<dd><p>Setup injectables (passed by parent process) within sub process</p>
<p>we sometimes want only one of the sub-processes to perform an action (e.g. write shadow prices)
the locutor flag indicates that this sub process is the designated singleton spokesperson</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>injectables</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict {&lt;injectable_name&gt;: &lt;value&gt;}</span></dt>
<dd><p class="first last">dict of injectables passed by parent process</p>
</dd>
<dt><strong>locutor</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">is this sub process the designated spokesperson</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>injects injectables</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.mp_tasks.write_breadcrumbs">
<code class="descclassname">activitysim.core.mp_tasks.</code><code class="descname">write_breadcrumbs</code><span class="sig-paren">(</span><em>breadcrumbs</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.mp_tasks.write_breadcrumbs" title="Permalink to this definition">¶</a></dt>
<dd><p>Write breadcrumbs file with execution history of multiprocess run</p>
<p>Write steps as array so order is preserved (step names are duplicated in steps)</p>
<p>Extract from breadcrumbs file showing completed mp_households step with 2 processes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">apportion</span><span class="p">:</span> <span class="n">true</span>
  <span class="n">coalesce</span><span class="p">:</span> <span class="n">true</span>
  <span class="n">completed</span><span class="p">:</span> <span class="p">[</span><span class="n">mp_households_0</span><span class="p">,</span> <span class="n">mp_households_1</span><span class="p">]</span>
  <span class="n">name</span><span class="p">:</span> <span class="n">mp_households</span>
  <span class="n">simulate</span><span class="p">:</span> <span class="n">true</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>breadcrumbs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">OrderedDict</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="data-management">
<h2>Data Management<a class="headerlink" href="#data-management" title="Permalink to this headline">¶</a></h2>
<div class="section" id="skim">
<span id="skims-in-detail"></span><h3>Skim<a class="headerlink" href="#skim" title="Permalink to this headline">¶</a></h3>
<p>Skim matrix data access</p>
<div class="section" id="id1">
<h4>API<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<span class="target" id="module-activitysim.core.skim"></span><dl class="class">
<dt id="activitysim.core.skim.DataFrameMatrix">
<em class="property">class </em><code class="descclassname">activitysim.core.skim.</code><code class="descname">DataFrameMatrix</code><span class="sig-paren">(</span><em>df</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.DataFrameMatrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility class to allow a pandas dataframe to be treated like a 2-D array,
indexed by rowid, colname</p>
<p>For use in vectorized expressions where the desired values depend on both a row column selector
e.g. size_terms.get(df.dest_taz, df.purpose)</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">50</span><span class="p">]},</span> <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">101</span><span class="p">,</span><span class="mi">102</span><span class="p">,</span><span class="mi">103</span><span class="p">,</span><span class="mi">104</span><span class="p">])</span>

<span class="n">dfm</span> <span class="o">=</span> <span class="n">DataFrameMatrix</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="n">dfm</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">row_ids</span><span class="o">=</span><span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">103</span><span class="p">],</span> <span class="n">col_ids</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">])</span>

<span class="n">returns</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span>  <span class="mi">4</span><span class="p">]</span>
</pre></div>
</div>
<dl class="method">
<dt id="activitysim.core.skim.DataFrameMatrix.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>self</em>, <em>row_ids</em>, <em>col_ids</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.DataFrameMatrix.get" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>row_ids - list of row_ids (df index values)</strong></dt>
<dd></dd>
<dt><strong>col_ids - list of column names, one per row_id,</strong></dt>
<dd><p class="first last">specifying column from which the value for that row should be retrieved</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>series with one row per row_id, with the value from the column specified in col_ids</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="activitysim.core.skim.OffsetMapper">
<em class="property">class </em><code class="descclassname">activitysim.core.skim.</code><code class="descname">OffsetMapper</code><span class="sig-paren">(</span><em>offset_int=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.OffsetMapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility to map skim zone ids to ordinal offsets (e.g. numpy array indices)</p>
<p>Can map either by a fixed offset (e.g. -1 to map 1-based to 0-based)
or by an explicit mapping of zone id to offset (slower but more flexible)</p>
<dl class="method">
<dt id="activitysim.core.skim.OffsetMapper.map">
<code class="descname">map</code><span class="sig-paren">(</span><em>self</em>, <em>zone_ids</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.OffsetMapper.map" title="Permalink to this definition">¶</a></dt>
<dd><p>map zone_ids to offsets</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>zone_ids</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>offsets</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array of int</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.skim.OffsetMapper.set_offset_int">
<code class="descname">set_offset_int</code><span class="sig-paren">(</span><em>self</em>, <em>offset_int</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.OffsetMapper.set_offset_int" title="Permalink to this definition">¶</a></dt>
<dd><p>specify fixed offset (e.g. -1 to map 1-based to 0-based)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>offset_int</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.skim.OffsetMapper.set_offset_list">
<code class="descname">set_offset_list</code><span class="sig-paren">(</span><em>self</em>, <em>offset_list</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.OffsetMapper.set_offset_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Specify the zone ids corresponding to the offsets (ordinal positions)</p>
<p>set_offset_list([10, 20, 30, 40])
map([30, 20, 40])
returns offsets [2, 1, 3]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>offset_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="activitysim.core.skim.SkimDict">
<em class="property">class </em><code class="descclassname">activitysim.core.skim.</code><code class="descname">SkimDict</code><span class="sig-paren">(</span><em>skim_data</em>, <em>skim_info</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimDict" title="Permalink to this definition">¶</a></dt>
<dd><p>A SkimDict object is a wrapper around a dict of multiple skim objects,
where each object is identified by a key.  It operates like a
dictionary - i.e. use brackets to add and get skim objects.</p>
<p>Note that keys are either strings or tuples of two strings (to support stacking of skims.)</p>
<dl class="method">
<dt id="activitysim.core.skim.SkimDict.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>self</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimDict.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an available wrapped skim object (not the lookup)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">hashable</span></dt>
<dd><p class="first last">The key (identifier) for this skim object</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>skim: Skim</dt>
<dd><p class="first last">The skim object</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.skim.SkimDict.wrap">
<code class="descname">wrap</code><span class="sig-paren">(</span><em>self</em>, <em>left_key</em>, <em>right_key</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimDict.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>return a SkimDictWrapper for self</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="activitysim.core.skim.SkimDictWrapper">
<em class="property">class </em><code class="descclassname">activitysim.core.skim.</code><code class="descname">SkimDictWrapper</code><span class="sig-paren">(</span><em>skim_dict</em>, <em>left_key</em>, <em>right_key</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimDictWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>A SkimDictWrapper object is an access wrapper around a SkimDict of multiple skim objects,
where each object is identified by a key.  It operates like a
dictionary - i.e. use brackets to add and get skim objects - but also
has information on how to lookup against the skim objects.
Specifically, this object has a dataframe, a left_key and right_key.
It is assumed that left_key and right_key identify columns in df.  The
parameter df is usually set by the simulation itself as it’s a result of
interacting choosers and alternatives.</p>
<p>When the user calls skims[key], key is an identifier for which skim
to use, and the object automatically looks up impedances of that skim
using the specified left_key column in df as the origin and
the right_key column in df as the destination.  In this way, the user
does not do the O-D lookup by hand and only specifies which skim to use
for this lookup.  This is the only purpose of this object: to
abstract away the O-D lookup and use skims by specifying which skim
to use in the expressions.</p>
<p>Note that keys are either strings or tuples of two strings (to support stacking of skims.)</p>
<dl class="method">
<dt id="activitysim.core.skim.SkimDictWrapper.lookup">
<code class="descname">lookup</code><span class="sig-paren">(</span><em>self</em>, <em>key</em>, <em>reverse=False</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimDictWrapper.lookup" title="Permalink to this definition">¶</a></dt>
<dd><p>Generally not called by the user - use __getitem__ instead</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">hashable</span></dt>
<dd><p class="first last">The key (identifier) for this skim object</p>
</dd>
<dt><strong>od</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool (optional)</span></dt>
<dd><p class="first last">od=True means lookup standard origin-destination skim value
od=False means lookup destination-origin skim value</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>impedances: pd.Series</dt>
<dd><p class="first last">A Series of impedances which are elements of the Skim object and
with the same index as df</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.skim.SkimDictWrapper.max">
<code class="descname">max</code><span class="sig-paren">(</span><em>self</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimDictWrapper.max" title="Permalink to this definition">¶</a></dt>
<dd><p>return max skim value in either o-d or d-o direction</p>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.skim.SkimDictWrapper.reverse">
<code class="descname">reverse</code><span class="sig-paren">(</span><em>self</em>, <em>key</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimDictWrapper.reverse" title="Permalink to this definition">¶</a></dt>
<dd><p>return skim value in reverse (d-o) direction</p>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.skim.SkimDictWrapper.set_df">
<code class="descname">set_df</code><span class="sig-paren">(</span><em>self</em>, <em>df</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimDictWrapper.set_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the dataframe</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd><p class="first last">The dataframe which contains the origin and destination ids</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>Nothing</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="activitysim.core.skim.SkimStack">
<em class="property">class </em><code class="descclassname">activitysim.core.skim.</code><code class="descname">SkimStack</code><span class="sig-paren">(</span><em>skim_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimStack" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="activitysim.core.skim.SkimStack.wrap">
<code class="descname">wrap</code><span class="sig-paren">(</span><em>self</em>, <em>left_key</em>, <em>right_key</em>, <em>skim_key</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimStack.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>return a SkimStackWrapper for self</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="activitysim.core.skim.SkimStackWrapper">
<em class="property">class </em><code class="descclassname">activitysim.core.skim.</code><code class="descname">SkimStackWrapper</code><span class="sig-paren">(</span><em>stack</em>, <em>left_key</em>, <em>right_key</em>, <em>skim_key</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimStackWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>A SkimStackWrapper object wraps a SkimStack object to add an additional wrinkle of
lookup functionality.  Upon init the separate skims objects are
processed into a 3D matrix so that lookup of the different skims can
be performed quickly for each row in the dataframe.  In this very
particular formulation, the keys are assumed to be tuples with two
elements - the second element of which will be taken from the
different rows in the dataframe.  The first element can then be
dereferenced like an array.  This is useful, for instance, to have a
certain skim vary by time of day - the skims are set with keys of
(‘SOV’, ‘AM”), (‘SOV’, ‘PM’) etc.  The time of day is then taken to
be different for every row in the tours table, and the ‘SOV’ portion
of the key can be used in __getitem__.</p>
<p>To be more explicit, the input is a dictionary of Skims objects, each of
which contains a 2D matrix.  These are stacked into a 3D matrix with a
mapping of keys to indexes which is applied using pandas .map to a third
column in the object dataframe.  The three columns - left_key and
right_key from the Skims object and skim_key from this one, are then used to
dereference the 3D matrix.  The tricky part comes in defining the key which
matches the 3rd dimension of the matrix, and the key which is passed into
__getitem__ below (i.e. the one used in the specs).  By convention,
every key in the Skims object that is passed in MUST be a tuple with 2
items.  The second item in the tuple maps to the items in the dataframe
referred to by the skim_key column and the first item in the tuple is
then available to pass directly to __getitem__.</p>
<p>The sum conclusion of this is that in the specs, you can say something
like out_skim[‘SOV’] and it will automatically dereference the 3D matrix
using origin, destination, and time of day.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>skims: Skims</strong></dt>
<dd><p class="first last">This is the Skims object to wrap</p>
</dd>
<dt><strong>skim_key</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">This identifies the column in the dataframe which is used to
select among Skim object using the SECOND item in each tuple (see
above for a more complete description)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="activitysim.core.skim.SkimStackWrapper.set_df">
<code class="descname">set_df</code><span class="sig-paren">(</span><em>self</em>, <em>df</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimStackWrapper.set_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the dataframe</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">DataFrame</span></dt>
<dd><p class="first last">The dataframe which contains the origin and destination ids</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>Nothing</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="activitysim.core.skim.SkimWrapper">
<em class="property">class </em><code class="descclassname">activitysim.core.skim.</code><code class="descname">SkimWrapper</code><span class="sig-paren">(</span><em>data</em>, <em>offset_mapper=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimWrapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Container for skim arrays.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>data</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2D array</span></dt>
<dd></dd>
<dt><strong>offset</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">An optional offset that will be added to origin/destination
values to turn them into array indices.
For example, if zone IDs are 1-based, an offset of -1
would turn them into 0-based array indices.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="activitysim.core.skim.SkimWrapper.get">
<code class="descname">get</code><span class="sig-paren">(</span><em>self</em>, <em>orig</em>, <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.skim.SkimWrapper.get" title="Permalink to this definition">¶</a></dt>
<dd><p>Get impedence values for a set of origin, destination pairs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>orig</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd></dd>
<dt><strong>dest</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>values</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1D array</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="pipeline">
<span id="pipeline-in-detail"></span><h3>Pipeline<a class="headerlink" href="#pipeline" title="Permalink to this headline">¶</a></h3>
<p>Data pipeline manager, which manages the list of model steps, runs them via orca, reads
and writes data tables from/to the pipeline datastore, and supports restarting of the pipeline
at any model step.</p>
<div class="section" id="id2">
<h4>API<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<span class="target" id="module-activitysim.core.pipeline"></span><dl class="class">
<dt id="activitysim.core.pipeline.Pipeline">
<em class="property">class </em><code class="descclassname">activitysim.core.pipeline.</code><code class="descname">Pipeline</code><a class="headerlink" href="#activitysim.core.pipeline.Pipeline" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.add_checkpoint">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">add_checkpoint</code><span class="sig-paren">(</span><em>checkpoint_name</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.add_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a new checkpoint with specified name, write all data required to restore the simulation
to its current state.</p>
<p>Detect any changed tables , re-wrap them and write the current version to the pipeline store.
Write the current state of the random number generator.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>checkpoint_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.checkpointed_tables">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">checkpointed_tables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.checkpointed_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the names of all checkpointed tables</p>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.close_pipeline">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">close_pipeline</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.close_pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Close any known open files</p>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.extend_table">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">extend_table</code><span class="sig-paren">(</span><em>table_name</em>, <em>df</em>, <em>axis=0</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.extend_table" title="Permalink to this definition">¶</a></dt>
<dd><p>add new table or extend (add rows) to an existing table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>table_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">orca/inject table name</p>
</dd>
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas DataFrame</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.get_checkpoints">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">get_checkpoints</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.get_checkpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Get pandas dataframe of info about all checkpoints stored in pipeline</p>
<p>pipeline doesn’t have to be open</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>checkpoints_df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.get_pipeline_store">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">get_pipeline_store</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.get_pipeline_store" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the open pipeline hdf5 checkpoint store or return None if it not been opened</p>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.get_rn_generator">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">get_rn_generator</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.get_rn_generator" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the singleton random number object</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>activitysim.random.Random</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.get_table">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">get_table</code><span class="sig-paren">(</span><em>table_name</em>, <em>checkpoint_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.get_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Return pandas dataframe corresponding to table_name</p>
<p>if checkpoint_name is None, return the current (most recent) version of the table.
The table can be a checkpointed table or any registered orca table (e.g. function table)</p>
<p>if checkpoint_name is specified, return table as it was at that checkpoint
(the most recently checkpointed version of the table at or before checkpoint_name)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>table_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd></dd>
<dt><strong>checkpoint_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.last_checkpoint">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">last_checkpoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.last_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>last_checkpoint: str</dt>
<dd><p class="first last">name of last checkpoint</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.load_checkpoint">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">load_checkpoint</code><span class="sig-paren">(</span><em>checkpoint_name</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.load_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Load dataframes and restore random number channel state from pipeline hdf5 file.
This restores the pipeline state that existed at the specified checkpoint in a prior simulation.
This allows us to resume the simulation after the specified checkpoint</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>checkpoint_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">model_name of checkpoint to load (resume_after argument to open_pipeline)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.open_pipeline">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">open_pipeline</code><span class="sig-paren">(</span><em>resume_after=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.open_pipeline" title="Permalink to this definition">¶</a></dt>
<dd><p>Start pipeline, either for a new run or, if resume_after, loading checkpoint from pipeline.</p>
<p>If resume_after, then we expect the pipeline hdf5 file to exist and contain
checkpoints from a previous run, including a checkpoint with name specified in resume_after</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>resume_after</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span></dt>
<dd><p class="first last">name of checkpoint to load from pipeline store</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.open_pipeline_store">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">open_pipeline_store</code><span class="sig-paren">(</span><em>overwrite=False</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.open_pipeline_store" title="Permalink to this definition">¶</a></dt>
<dd><p>Open the pipeline checkpoint store</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>overwrite</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">delete file before opening (unless resuming)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.orca_dataframe_tables">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">orca_dataframe_tables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.orca_dataframe_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of the neames of all currently registered dataframe tables</p>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.read_df">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">read_df</code><span class="sig-paren">(</span><em>table_name</em>, <em>checkpoint_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.read_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a pandas dataframe from the pipeline store.</p>
<p>We store multiple versions of all simulation tables, for every checkpoint in which they change,
so we need to know both the table_name and the checkpoint_name of hte desired table.</p>
<p>The only exception is the checkpoints dataframe, which just has a table_name</p>
<p>An error will be raised by HDFStore if the table is not found</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>table_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd></dd>
<dt><strong>checkpoint_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">the dataframe read from the store</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.replace_table">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">replace_table</code><span class="sig-paren">(</span><em>table_name</em>, <em>df</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.replace_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Add or replace a orca table, removing any existing added orca columns</p>
<p>The use case for this function is a method that calls to_frame on an orca table, modifies
it and then saves the modified.</p>
<p>orca.to_frame returns a copy, so no changes are saved, and adding multiple column with
add_column adds them in an indeterminate order.</p>
<p>Simply replacing an existing the table “behind the pipeline’s back” by calling orca.add_table
risks pipeline to failing to detect that it has changed, and thus not checkpoint the changes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>table_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">orca/pipeline table name</p>
</dd>
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas DataFrame</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.rewrap">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">rewrap</code><span class="sig-paren">(</span><em>table_name</em>, <em>df=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.rewrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Add or replace an orca registered table as a unitary DataFrame-backed DataFrameWrapper table</p>
<p>if df is None, then get the dataframe from orca (table_name should be registered, or
an error will be thrown) which may involve evaluating added columns, etc.</p>
<p>If the orca table already exists, deregister it along with any associated columns before
re-registering it.</p>
<p>The net result is that the dataframe is a registered orca DataFrameWrapper table with no
computed or added columns.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>table_name</strong></dt>
<dd></dd>
<dt><strong>df</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>the underlying df of the rewrapped table</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.run">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">run</code><span class="sig-paren">(</span><em>models</em>, <em>resume_after=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.run" title="Permalink to this definition">¶</a></dt>
<dd><p>run the specified list of models, optionally loading checkpoint and resuming after specified
checkpoint.</p>
<p>Since we use model_name as checkpoint name, the same model may not be run more than once.</p>
<p>If resume_after checkpoint is specified and a model with that name appears in the models list,
then we only run the models after that point in the list. This allows the user always to pass
the same list of models, but specify a resume_after point if desired.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>models</strong> <span class="classifier-delimiter">:</span> <span class="classifier">[str]</span></dt>
<dd><p class="first last">list of model_names</p>
</dd>
<dt><strong>resume_after</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str or None</span></dt>
<dd><p class="first last">model_name of checkpoint to load checkpoint and AFTER WHICH to resume model run</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.run_model">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">run_model</code><span class="sig-paren">(</span><em>model_name</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.run_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Run the specified model and add checkpoint for model_name</p>
<p>Since we use model_name as checkpoint name, the same model may not be run more than once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>model_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">model_name is assumed to be the name of a registered orca step</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.split_arg">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">split_arg</code><span class="sig-paren">(</span><em>s</em>, <em>sep</em>, <em>default=''</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.split_arg" title="Permalink to this definition">¶</a></dt>
<dd><p>split str s in two at first sep, returning empty string as second result if no sep</p>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.pipeline.write_df">
<code class="descclassname">activitysim.core.pipeline.</code><code class="descname">write_df</code><span class="sig-paren">(</span><em>df</em>, <em>table_name</em>, <em>checkpoint_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.pipeline.write_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a pandas dataframe to the pipeline store.</p>
<p>We store multiple versions of all simulation tables, for every checkpoint in which they change,
so we need to know both the table_name and the checkpoint_name to label the saved table</p>
<p>The only exception is the checkpoints dataframe, which just has a table_name</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">dataframe to store</p>
</dd>
<dt><strong>table_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">also conventionally the orca table name</p>
</dd>
<dt><strong>checkpoint_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">the checkpoint at which the table was created/modified</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="random">
<span id="random-in-detail"></span><h3>Random<a class="headerlink" href="#random" title="Permalink to this headline">¶</a></h3>
<p>ActivitySim’s random number generation has a number of important features unique to AB modeling:</p>
<ul class="simple">
<li>Regression testing, debugging - run the exact model with the same inputs and get exactly the same results.</li>
<li>Debugging models - run the exact model with the same inputs but with changes to expression files and get the same results except where the equations differ.</li>
<li>Since runs can take a while, the above cases need to work with a restartable pipeline.</li>
<li>Debugging Multithreading - run the exact model with different multithreading configurations and get the same results.</li>
<li>Repeatable household-level choices - results for a household are repeatable when run with different sample sizes</li>
<li>Repeatable household level results with different scenarios - results for a household are repeatable with different scenario configurations sequentially up to the point at which those differences emerge, and in alternate submodels in which those differences do not apply.</li>
</ul>
<p>Random number generation is done using the <a class="reference external" href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.random.RandomState.html">numpy Mersenne Twister PNRG</a>.
ActivitySim seeds on-the-fly and uses a stream of random numbers seeded by the household id, person id, tour id, trip id, the model step offset, and the global seed.
The logic for calculating the seed is something along the lines of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">chooser_table</span><span class="o">.</span><span class="n">index</span> <span class="o">*</span> <span class="n">number_of_models_for_chooser</span> <span class="o">+</span> <span class="n">chooser_model_offset</span> <span class="o">+</span> <span class="n">global_seed_offset</span>

<span class="k">for</span> <span class="n">example</span>
  <span class="mi">1425</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">0</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">where</span><span class="p">:</span>
  <span class="mi">1425</span> <span class="o">=</span> <span class="n">household</span> <span class="n">table</span> <span class="n">index</span> <span class="o">-</span> <span class="n">households</span><span class="o">.</span><span class="n">id</span>
  <span class="mi">2</span> <span class="o">=</span> <span class="n">number</span> <span class="n">of</span> <span class="n">household</span> <span class="n">level</span> <span class="n">models</span> <span class="o">-</span> <span class="n">auto</span> <span class="n">ownership</span> <span class="ow">and</span> <span class="n">cdap</span>
  <span class="mi">0</span> <span class="o">=</span> <span class="n">first</span> <span class="n">household</span> <span class="n">model</span> <span class="o">-</span> <span class="n">auto</span> <span class="n">ownership</span>
  <span class="mi">1</span> <span class="o">=</span> <span class="k">global</span> <span class="n">seed</span> <span class="n">offset</span> <span class="k">for</span> <span class="n">testing</span> <span class="n">the</span> <span class="n">same</span> <span class="n">model</span> <span class="n">under</span> <span class="n">different</span> <span class="n">random</span> <span class="k">global</span> <span class="n">seeds</span>
</pre></div>
</div>
<p>ActivitySim generates a separate, distinct, and stable random number stream for each tour type and tour number in order to maintain as much stability as is
possible across alternative scenarios.  This is done for trips as well, by direction (inbound versus outbound).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The Random module contains max model steps constants by chooser type - household, person, tour, trip - needs to be equal to the number of chooser sub-models.</p>
</div>
<div class="section" id="id3">
<h4>API<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<span class="target" id="module-activitysim.core.random"></span><dl class="class">
<dt id="activitysim.core.random.Random">
<em class="property">class </em><code class="descclassname">activitysim.core.random.</code><code class="descname">Random</code><a class="headerlink" href="#activitysim.core.random.Random" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="activitysim.core.random.Random.add_channel">
<code class="descname">add_channel</code><span class="sig-paren">(</span><em>self</em>, <em>channel_name</em>, <em>domain_df</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.Random.add_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Create or extend a channel for generating random number streams for domain_df.</p>
<p>We need to be prepared to extend an existing channel because mandatory and non-mandatory
tours are generated separately by different sub-models, but end up members of a common
tours channel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>domain_df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">domain dataframe with index values for which random streams are to be generated
and well-known index name corresponding to the channel</p>
</dd>
<dt><strong>channel_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">expected channel name provided as a consistency check</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.Random.begin_step">
<code class="descname">begin_step</code><span class="sig-paren">(</span><em>self</em>, <em>step_name</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.Random.begin_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Register that the pipeline has entered a new step and that global and channel streams
should transition to the new stream.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>step_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">pipeline step name</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.Random.choice_for_df">
<code class="descname">choice_for_df</code><span class="sig-paren">(</span><em>self</em>, <em>df</em>, <em>a</em>, <em>size</em>, <em>replace</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.Random.choice_for_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply numpy.random.choice once for each row in df
using the appropriate random channel for each row.</p>
<p>Concatenate the the choice arrays for every row into a single 1-D ndarray
The resulting array will be of length: size * len(df.index)
This method is designed to support creation of a interaction_dataset</p>
<p>The columns in df are ignored; the index name and values are used to determine
which random number sequence to to use.</p>
<p>We assume that we can identify the channel to used based on the name of df.index
This channel should have already been registered by a call to add_channel (q.v.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">df with index name and values corresponding to a registered channel</p>
</dd>
<dt><strong>The remaining parameters are passed through as arguments to numpy.random.choice</strong></dt>
<dd></dd>
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array-like or int</span></dt>
<dd><p class="first last">If an ndarray, a random sample is generated from its elements.
If an int, the random sample is generated as if a was np.arange(n)</p>
</dd>
<dt><strong>size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of ints</span></dt>
<dd><p class="first last">Output shape</p>
</dd>
<dt><strong>replace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">Whether the sample is with or without replacement</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>choices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D ndarray of length: size * len(df.index)</span></dt>
<dd><p class="first last">The generated random samples for each row concatenated into a single (flat) array</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.Random.drop_channel">
<code class="descname">drop_channel</code><span class="sig-paren">(</span><em>self</em>, <em>channel_name</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.Random.drop_channel" title="Permalink to this definition">¶</a></dt>
<dd><p>Drop channel that won’t be used again (saves memory)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>channel_name</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.Random.end_step">
<code class="descname">end_step</code><span class="sig-paren">(</span><em>self</em>, <em>step_name</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.Random.end_step" title="Permalink to this definition">¶</a></dt>
<dd><p>This is mostly just for internal consistency checking -
I’m not sure it serves any useful purpose except to catch “mis-steps” in the pipeline code</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>step_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of current step (just a consistency check)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.Random.get_channel_for_df">
<code class="descname">get_channel_for_df</code><span class="sig-paren">(</span><em>self</em>, <em>df</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.Random.get_channel_for_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the channel for this df. Channel should already have been loaded/added.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.dataframe</span></dt>
<dd><p class="first last">either a domain_df for a channel being added or extended
or a df for which random values are to be generated</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.Random.get_external_rng">
<code class="descname">get_external_rng</code><span class="sig-paren">(</span><em>self</em>, <em>one_off_step_name</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.Random.get_external_rng" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a numpy random number generator for step-independent one_off use</p>
<p>exists to allow sampling of input tables consistent no matter what step they are called in</p>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.Random.get_global_rng">
<code class="descname">get_global_rng</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.Random.get_global_rng" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a numpy random number generator for use within current step.</p>
<p>This method is designed to provide random numbers for uses that do not correspond to
known channel domains. e.g. to select a subset of households to use for the simulation.</p>
<p>global_rng is reseeded to a predictable value at the beginning of every step so that
it behaves repeatably when simulation is resumed or re-run.</p>
<p>If “true pseudo random” behavior is desired (i.e. NOT repeatable) the set_base_seed
method (q.v.) may be used to globally reseed all random streams.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>global_rng</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.random.RandomState()</span></dt>
<dd><p class="first last">numpy random number generator for use within current step</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.Random.lognormal_for_df">
<code class="descname">lognormal_for_df</code><span class="sig-paren">(</span><em>self</em>, <em>df</em>, <em>mu</em>, <em>sigma</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.Random.lognormal_for_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a single floating point random number in range [0, 1) for each row in df
using the appropriate random channel for each row.</p>
<p>Subsequent calls (in the same step) will return the next rand for each df row</p>
<p>The resulting array will be the same length (and order) as df
This method is designed to support alternative selection from a probability array</p>
<p>The columns in df are ignored; the index name and values are used to determine
which random number sequence to to use.</p>
<p>We assume that we can identify the channel to used based on the name of df.index
This channel should have already been registered by a call to add_channel (q.v.)</p>
<p>If “true pseudo random” behavior is desired (i.e. NOT repeatable) the set_base_seed
method (q.v.) may be used to globally reseed all random streams.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">df with index name and values corresponding to a registered channel</p>
</dd>
<dt><strong>mu</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or array of floats with one value per df row</span></dt>
<dd></dd>
<dt><strong>sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or array of floats with one value per df row</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rands</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D ndarray the same length as df</span></dt>
<dd><p class="first last">a single float in lognormal distribution for each row in df</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.Random.random_for_df">
<code class="descname">random_for_df</code><span class="sig-paren">(</span><em>self</em>, <em>df</em>, <em>n=1</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.Random.random_for_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a single floating point random number in range [0, 1) for each row in df
using the appropriate random channel for each row.</p>
<p>Subsequent calls (in the same step) will return the next rand for each df row</p>
<p>The resulting array will be the same length (and order) as df
This method is designed to support alternative selection from a probability array</p>
<p>The columns in df are ignored; the index name and values are used to determine
which random number sequence to to use.</p>
<p>We assume that we can identify the channel to used based on the name of df.index
This channel should have already been registered by a call to add_channel (q.v.)</p>
<p>If “true pseudo random” behavior is desired (i.e. NOT repeatable) the set_base_seed
method (q.v.) may be used to globally reseed all random streams.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">df with index name and values corresponding to a registered channel</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">number of rands desired (default 1)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>choices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D ndarray the same length as df</span></dt>
<dd><p class="first last">a single float in range [0, 1) for each row in df</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.Random.set_base_seed">
<code class="descname">set_base_seed</code><span class="sig-paren">(</span><em>self</em>, <em>seed=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.Random.set_base_seed" title="Permalink to this definition">¶</a></dt>
<dd><p>Like seed for numpy.random.RandomState, but generalized for use with all random streams.</p>
<p>Provide a base seed that will be added to the seeds of all random streams.
The default base seed value is 0, so set_base_seed(0) is a NOP</p>
<p>set_base_seed(1) will (e.g.) provide a different set of random streams than the default
but will provide repeatable results re-running or resuming the simulation</p>
<p>set_base_seed(None) will set the base seed to a random and unpredictable integer and so
provides “fully pseudo random” non-repeatable streams with different results every time</p>
<p>Must be called before first step (before any channels are added or rands are consumed)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>seed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or None</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="activitysim.core.random.SimpleChannel">
<em class="property">class </em><code class="descclassname">activitysim.core.random.</code><code class="descname">SimpleChannel</code><span class="sig-paren">(</span><em>channel_name</em>, <em>base_seed</em>, <em>domain_df</em>, <em>step_name</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.SimpleChannel" title="Permalink to this definition">¶</a></dt>
<dd><p>We need to ensure that we generate the same random streams (when re-run or even across
different simulations.) We do this by generating a random seed for each domain_df row
that is based on the domain_df index (which implies that generated tables like tours
and trips are also created with stable, predictable, repeatable row indexes.</p>
<p>Because we need to generate a distinct stream for each step, we can’t just use the
domain_df index - we need a strategy for handling multiple steps without generating
collisions between streams (i.e. choosing the same seed for more than one stream.)</p>
<p>The easiest way to do this would be to use an array of integers to seed the generator,
with a global seed, a channel seed, a row seed, and a step seed. Unfortunately, seeding
numpy RandomState with arrays is a LOT slower than with a single integer seed, and
speed matters because we reseed on-the-fly for every call because creating a different
RandomState object for each row uses too much memory (5K per RandomState object)</p>
<p>numpy random seeds are unsigned int32 so there are 4,294,967,295 available seeds.
That is probably just about enough to distribute evenly, for most cities, depending on the
number of households, persons, tours, trips, and steps.</p>
<p>So we use (global_seed + channel_seed + step_seed + row_index) % (1 &lt;&lt; 32)
to get an int32 seed rather than a tuple.</p>
<p>We do read in the whole households and persons tables at start time, so we could note the
max index values. But we might then want a way to ensure stability between the test, example,
and full datasets. I am punting on this for now.</p>
<dl class="method">
<dt id="activitysim.core.random.SimpleChannel.begin_step">
<code class="descname">begin_step</code><span class="sig-paren">(</span><em>self</em>, <em>step_name</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.SimpleChannel.begin_step" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset channel state for a new state</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>step_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">pipeline step name for this step</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.SimpleChannel.choice_for_df">
<code class="descname">choice_for_df</code><span class="sig-paren">(</span><em>self</em>, <em>df</em>, <em>step_name</em>, <em>a</em>, <em>size</em>, <em>replace</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.SimpleChannel.choice_for_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply numpy.random.choice once for each row in df
using the appropriate random channel for each row.</p>
<p>Concatenate the the choice arrays for every row into a single 1-D ndarray
The resulting array will be of length: size * len(df.index)
This method is designed to support creation of a interaction_dataset</p>
<p>The columns in df are ignored; the index name and values are used to determine
which random number sequence to to use.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">df with index name and values corresponding to a registered channel</p>
</dd>
<dt><strong>step_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">current step name so we can update row_states seed info</p>
</dd>
<dt><strong>The remaining parameters are passed through as arguments to numpy.random.choice</strong></dt>
<dd></dd>
<dt><strong>a</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D array-like or int</span></dt>
<dd><p class="first last">If an ndarray, a random sample is generated from its elements.
If an int, the random sample is generated as if a was np.arange(n)</p>
</dd>
<dt><strong>size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or tuple of ints</span></dt>
<dd><p class="first last">Output shape</p>
</dd>
<dt><strong>replace</strong> <span class="classifier-delimiter">:</span> <span class="classifier">boolean</span></dt>
<dd><p class="first last">Whether the sample is with or without replacement</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>choices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">1-D ndarray of length: size * len(df.index)</span></dt>
<dd><p class="first last">The generated random samples for each row concatenated into a single (flat) array</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.SimpleChannel.extend_domain">
<code class="descname">extend_domain</code><span class="sig-paren">(</span><em>self</em>, <em>domain_df</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.SimpleChannel.extend_domain" title="Permalink to this definition">¶</a></dt>
<dd><p>Extend or create row_state df by adding seed info for each row in domain_df</p>
<p>If extending, the index values of new tables must be disjoint so
there will be no ambiguity/collisions between rows</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>domain_df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">domain dataframe with index values for which random streams are to be generated
and well-known index name corresponding to the channel</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.SimpleChannel.init_row_states_for_step">
<code class="descname">init_row_states_for_step</code><span class="sig-paren">(</span><em>self</em>, <em>row_states</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.SimpleChannel.init_row_states_for_step" title="Permalink to this definition">¶</a></dt>
<dd><p>initialize row states (in place) for new step</p>
<p>with stable, predictable, repeatable row_seeds for that domain_df index value</p>
<p>See notes on the seed generation strategy in class comment above.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>row_states</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.SimpleChannel.lognormal_for_df">
<code class="descname">lognormal_for_df</code><span class="sig-paren">(</span><em>self</em>, <em>df</em>, <em>step_name</em>, <em>mu</em>, <em>sigma</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.SimpleChannel.lognormal_for_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a floating point random number in lognormal distribution for each row in df
using the appropriate random channel for each row.</p>
<p>Subsequent calls (in the same step) will return the next rand for each df row</p>
<p>The resulting array will be the same length (and order) as df
This method is designed to support alternative selection from a probability array</p>
<p>The columns in df are ignored; the index name and values are used to determine
which random number sequence to to use.</p>
<p>If “true pseudo random” behavior is desired (i.e. NOT repeatable) the set_base_seed
method (q.v.) may be used to globally reseed all random streams.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame or Series</span></dt>
<dd><p class="first last">df or series with index name and values corresponding to a registered channel</p>
</dd>
<dt><strong>mu</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or pd.Series or array of floats with one value per df row</span></dt>
<dd></dd>
<dt><strong>sigma</strong> <span class="classifier-delimiter">:</span> <span class="classifier">float or array of floats with one value per df row</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rands</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2-D ndarray</span></dt>
<dd><p class="first last">array the same length as df, with n floats in range [0, 1) for each df row</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.random.SimpleChannel.random_for_df">
<code class="descname">random_for_df</code><span class="sig-paren">(</span><em>self</em>, <em>df</em>, <em>step_name</em>, <em>n=1</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.SimpleChannel.random_for_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Return n floating point random numbers in range [0, 1) for each row in df
using the appropriate random channel for each row.</p>
<p>Subsequent calls (in the same step) will return the next rand for each df row</p>
<p>The resulting array will be the same length (and order) as df
This method is designed to support alternative selection from a probability array</p>
<p>The columns in df are ignored; the index name and values are used to determine
which random number sequence to to use.</p>
<p>If “true pseudo random” behavior is desired (i.e. NOT repeatable) the set_base_seed
method (q.v.) may be used to globally reseed all random streams.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">df with index name and values corresponding to a registered channel</p>
</dd>
<dt><strong>n</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">number of rands desired per df row</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>rands</strong> <span class="classifier-delimiter">:</span> <span class="classifier">2-D ndarray</span></dt>
<dd><p class="first last">array the same length as df, with n floats in range [0, 1) for each df row</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="activitysim.core.random.hash32">
<code class="descclassname">activitysim.core.random.</code><code class="descname">hash32</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.random.hash32" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>s: str</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>32 bit unsigned hash</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="tracing">
<h3>Tracing<a class="headerlink" href="#tracing" title="Permalink to this headline">¶</a></h3>
<p>Household tracer.  If a household trace ID is specified, then ActivitySim will output a
comprehensive set of trace files for all calculations for all household members:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">hhtrace.log</span></code> - household trace log file, which specifies the CSV files traced. The order of output files is consistent with the model sequence.</li>
<li><code class="docutils literal notranslate"><span class="pre">various</span> <span class="pre">CSV</span> <span class="pre">files</span></code> - every input, intermediate, and output data table - chooser, expressions/utilities, probabilities, choices, etc. - for the trace household for every sub-model</li>
</ul>
<p>With the set of output CSV files, the user can trace ActivitySim’s calculations in order to ensure they are correct and/or to
help debug data and/or logic errors.</p>
<div class="section" id="id4">
<h4>API<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<span class="target" id="module-activitysim.core.tracing"></span><dl class="function">
<dt id="activitysim.core.tracing.config_logger">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">config_logger</code><span class="sig-paren">(</span><em>basic=False</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.config_logger" title="Permalink to this definition">¶</a></dt>
<dd><p>Configure logger</p>
<p>look for conf file in configs_dir, if not found use basicConfig</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>Nothing</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.delete_csv_files">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">delete_csv_files</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.delete_csv_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete CSV files in output_dir</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>Nothing</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.delete_output_files">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">delete_output_files</code><span class="sig-paren">(</span><em>file_type</em>, <em>ignore=None</em>, <em>subdir=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.delete_output_files" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete files in output directory of specified type</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>output_dir: str</strong></dt>
<dd><p class="first last">Directory of trace output CSVs</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>Nothing</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.get_trace_target">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">get_trace_target</code><span class="sig-paren">(</span><em>df</em>, <em>slicer</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.get_trace_target" title="Permalink to this definition">¶</a></dt>
<dd><p>get target ids and column or index to identify target trace rows in df</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>df: pandas.DataFrame</strong></dt>
<dd><p class="first last">dataframe to slice</p>
</dd>
<dt><strong>slicer: str</strong></dt>
<dd><p class="first last">name of column or index to use for slicing</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>(target, column) tuple</dt>
<dd></dd>
<dt><strong>target</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int or list of ints</span></dt>
<dd><p class="first last">id or ids that identify tracer target rows</p>
</dd>
<dt><strong>column</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of column to search for targets or None to search index</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.hh_id_for_chooser">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">hh_id_for_chooser</code><span class="sig-paren">(</span><em>id</em>, <em>choosers</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.hh_id_for_chooser" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>id - scalar id (or list of ids) from chooser index</strong></dt>
<dd></dd>
<dt><strong>choosers - pandas dataframe whose index contains ids</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>scalar household_id or series of household_ids</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.interaction_trace_rows">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">interaction_trace_rows</code><span class="sig-paren">(</span><em>interaction_df</em>, <em>choosers</em>, <em>sample_size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.interaction_trace_rows" title="Permalink to this definition">¶</a></dt>
<dd><p>Trace model design for interaction_simulate</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>interaction_df: pandas.DataFrame</strong></dt>
<dd><p class="first last">traced model_design dataframe</p>
</dd>
<dt><strong>choosers: pandas.DataFrame</strong></dt>
<dd><p class="first last">interaction_simulate choosers
(needed to filter the model_design dataframe by traced hh or person id)</p>
</dd>
<dt><strong>sample_size int or None</strong></dt>
<dd><p class="first last">int for constant sample size, or None if choosers have different numbers of alternatives</p>
</dd>
<dt><strong>Returns</strong></dt>
<dd></dd>
<dt><strong>——-</strong></dt>
<dd></dd>
<dt><strong>trace_rows</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy.ndarray</span></dt>
<dd><p class="first last">array of booleans to flag which rows in interaction_df to trace</p>
</dd>
<dt><strong>trace_ids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple (str,  numpy.ndarray)</span></dt>
<dd><p class="first last">column name and array of trace_ids mapping trace_rows to their target_id
for use by trace_interaction_eval_results which needs to know target_id
so it can create separate tables for each distinct target for readability</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.no_results">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">no_results</code><span class="sig-paren">(</span><em>trace_label</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.no_results" title="Permalink to this definition">¶</a></dt>
<dd><p>standard no-op to write tracing when a model produces no results</p>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.print_summary">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">print_summary</code><span class="sig-paren">(</span><em>label</em>, <em>df</em>, <em>describe=False</em>, <em>value_counts=False</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.print_summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Print summary</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>label: str</strong></dt>
<dd><p class="first last">tracer name</p>
</dd>
<dt><strong>df: pandas.DataFrame</strong></dt>
<dd><p class="first last">traced dataframe</p>
</dd>
<dt><strong>describe: boolean</strong></dt>
<dd><p class="first last">print describe?</p>
</dd>
<dt><strong>value_counts: boolean</strong></dt>
<dd><p class="first last">print value counts?</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>Nothing</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.register_traceable_table">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">register_traceable_table</code><span class="sig-paren">(</span><em>table_name</em>, <em>df</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.register_traceable_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Register traceable table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>df: pandas.DataFrame</strong></dt>
<dd><p class="first last">traced dataframe</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>Nothing</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.slice_ids">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">slice_ids</code><span class="sig-paren">(</span><em>df</em>, <em>ids</em>, <em>column=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.slice_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>slice a dataframe to select only records with the specified ids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>df: pandas.DataFrame</strong></dt>
<dd><p class="first last">traced dataframe</p>
</dd>
<dt><strong>ids: int or list of ints</strong></dt>
<dd><p class="first last">slice ids</p>
</dd>
<dt><strong>column: str</strong></dt>
<dd><p class="first last">column to slice (slice using index if None)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>df: pandas.DataFrame</dt>
<dd><p class="first last">sliced dataframe</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.trace_df">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">trace_df</code><span class="sig-paren">(</span><em>df</em>, <em>label</em>, <em>slicer=None</em>, <em>columns=None</em>, <em>index_label=None</em>, <em>column_labels=None</em>, <em>transpose=True</em>, <em>warn_if_empty=False</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.trace_df" title="Permalink to this definition">¶</a></dt>
<dd><p>Slice dataframe by traced household or person id dataframe and write to CSV</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>df: pandas.DataFrame</strong></dt>
<dd><p class="first last">traced dataframe</p>
</dd>
<dt><strong>label: str</strong></dt>
<dd><p class="first last">tracer name</p>
</dd>
<dt><strong>slicer: Object</strong></dt>
<dd><p class="first last">slicer for subsetting</p>
</dd>
<dt><strong>columns: list</strong></dt>
<dd><p class="first last">columns to write</p>
</dd>
<dt><strong>index_label: str</strong></dt>
<dd><p class="first last">index name</p>
</dd>
<dt><strong>column_labels: [str, str]</strong></dt>
<dd><p class="first last">labels for columns in csv</p>
</dd>
<dt><strong>transpose: boolean</strong></dt>
<dd><p class="first last">whether to transpose file for legibility</p>
</dd>
<dt><strong>warn_if_empty: boolean</strong></dt>
<dd><p class="first last">write warning if sliced df is empty</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>Nothing</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.trace_interaction_eval_results">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">trace_interaction_eval_results</code><span class="sig-paren">(</span><em>trace_results</em>, <em>trace_ids</em>, <em>label</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.trace_interaction_eval_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Trace model design eval results for interaction_simulate</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>trace_results: pandas.DataFrame</strong></dt>
<dd><p class="first last">traced model_design dataframe</p>
</dd>
<dt><strong>trace_ids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">tuple (str,  numpy.ndarray)</span></dt>
<dd><p class="first last">column name and array of trace_ids from interaction_trace_rows()
used to filter the trace_results dataframe by traced hh or person id</p>
</dd>
<dt><strong>label: str</strong></dt>
<dd><p class="first last">tracer name</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>Nothing</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.tracing.write_csv">
<code class="descclassname">activitysim.core.tracing.</code><code class="descname">write_csv</code><span class="sig-paren">(</span><em>df</em>, <em>file_name</em>, <em>index_label=None</em>, <em>columns=None</em>, <em>column_labels=None</em>, <em>transpose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.tracing.write_csv" title="Permalink to this definition">¶</a></dt>
<dd><p>Print write_csv</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>df: pandas.DataFrame or pandas.Series</strong></dt>
<dd><p class="first last">traced dataframe</p>
</dd>
<dt><strong>file_name: str</strong></dt>
<dd><p class="first last">output file name</p>
</dd>
<dt><strong>index_label: str</strong></dt>
<dd><p class="first last">index name</p>
</dd>
<dt><strong>columns: list</strong></dt>
<dd><p class="first last">columns to write</p>
</dd>
<dt><strong>transpose: bool</strong></dt>
<dd><p class="first last">whether to transpose dataframe (ignored for series)</p>
</dd>
<dt><strong>Returns</strong></dt>
<dd></dd>
<dt><strong>——-</strong></dt>
<dd></dd>
<dt><strong>Nothing</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="utility-expressions">
<span id="expressions"></span><h2>Utility Expressions<a class="headerlink" href="#utility-expressions" title="Permalink to this headline">¶</a></h2>
<p>Much of the power of ActivitySim comes from being able to specify Python, pandas, and
numpy expressions for calculations. Refer to the pandas help for a general
introduction to expressions.  ActivitySim provides two ways to evaluate expressions:</p>
<ul class="simple">
<li>Simple table expressions are evaluated using <code class="docutils literal notranslate"><span class="pre">DataFrame.eval()</span></code>.  <a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.eval.html">pandas’ eval</a> operates on the current table.</li>
<li>Python expressions, denoted by beginning with <code class="docutils literal notranslate"><span class="pre">&#64;</span></code>, are evaluated with <a class="reference external" href="https://docs.python.org/2/library/functions.html#eval">Python’s eval()</a>.</li>
</ul>
<p>Simple table expressions can only refer to columns in the current DataFrame.  Python expressions can refer to any Python objects
urrently in memory.</p>
<div class="section" id="conventions">
<h3>Conventions<a class="headerlink" href="#conventions" title="Permalink to this headline">¶</a></h3>
<p>There are a few conventions for writing expressions in ActivitySim:</p>
<ul class="simple">
<li>each expression is applied to all rows in the table being operated on</li>
<li>expressions must be vectorized expressions and can use most numpy and pandas expressions</li>
<li>global constants are specified in the settings file</li>
<li>comments are specified with <code class="docutils literal notranslate"><span class="pre">#</span></code></li>
<li>you can refer to the current table being operated on as <code class="docutils literal notranslate"><span class="pre">df</span></code></li>
<li>often an object called <code class="docutils literal notranslate"><span class="pre">skims</span></code>, <code class="docutils literal notranslate"><span class="pre">skims_od</span></code>, or similar is available and is used to lookup the relevant skim information.  See <a class="reference internal" href="#skims-in-detail"><span class="std std-ref">Skim</span></a> for more information.</li>
<li>when editing the CSV files in Excel, use single quote ‘ or space at the start of a cell to get Excel to accept the expression</li>
</ul>
</div>
<div class="section" id="example-expressions-file">
<h3>Example Expressions File<a class="headerlink" href="#example-expressions-file" title="Permalink to this headline">¶</a></h3>
<p>An expressions file has the following basic form:</p>
<table border="1" class="docutils">
<colgroup>
<col width="39%" />
<col width="36%" />
<col width="13%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Expression</th>
<th class="head">cars0</th>
<th class="head">cars1</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>2 Adults (age 16+)</td>
<td>drivers==2</td>
<td>0</td>
<td>3.0773</td>
</tr>
<tr class="row-odd"><td>Persons age 35-34</td>
<td>num_young_adults</td>
<td>0</td>
<td>-0.4849</td>
</tr>
<tr class="row-even"><td>Number of workers, capped at 3</td>
<td>&#64;df.workers.clip(upper=3)</td>
<td>0</td>
<td>0.2936</td>
</tr>
<tr class="row-odd"><td>Distance, from 0 to 1 miles</td>
<td>&#64;skims[‘DIST’].clip(1)</td>
<td>-3.2451</td>
<td>-0.9523</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>Rows are vectorized expressions that will be calculated for every record in the current table being operated on</li>
<li>The Description column describes the expression</li>
<li>The Expression column contains a valid vectorized Python/pandas/numpy expression.  In the example above, <code class="docutils literal notranslate"><span class="pre">drivers</span></code> is a column in the current table.  Use <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> to refer to data outside the current table</li>
<li>There is a column for each alternative and its relevant coefficient</li>
</ul>
<p>There are some variations on this setup, but the functionality is similar.  For example,
in the example destination choice model, the size terms expressions file has market segments as rows and employment type
coefficients as columns.  Broadly speaking, there are currently four types of model expression configurations:</p>
<ul class="simple">
<li>Simple <a class="reference internal" href="#simulate"><span class="std std-ref">Simulate</span></a> choice model - select from a fixed set of choices defined in the specification file, such as the example above.</li>
<li><a class="reference internal" href="#simulate-with-interaction"><span class="std std-ref">Simulate with Interaction</span></a> choice model - combine the choice expressions with the choice alternatives files since the alternatives are not listed in the expressions file.  The <a class="reference internal" href="models.html#non-mandatory-tour-destination-choice"><span class="std std-ref">Non-Mandatory Tour Destination Choice</span></a> model implements this approach.</li>
<li>Complex choice model - an expressions file, a coefficients file, and a YAML settings file with model structural definition.  The <a class="reference internal" href="models.html#tour-mode-choice"><span class="std std-ref">Tour Mode Choice</span></a> models are examples of this and are illustrated below.</li>
<li>Combinatorial choice model - first generate a set of alternatives based on a combination of alternatives across choosers, and then make choices.  The <a class="reference internal" href="models.html#cdap"><span class="std std-ref">Coordinated Daily Activity Pattern</span></a> model implements this approach.</li>
</ul>
<p>The <a class="reference internal" href="models.html#tour-mode-choice"><span class="std std-ref">Tour Mode Choice</span></a> model is a complex choice model since the expressions file is structured a little bit differently, as shown below.
Each row is an expression for one of the alternatives, and each column contains either -999, 1, or blank.  The coefficients for each expression
is in a separate file, with a separate column for each alternative.  In the example below, the <code class="docutils literal notranslate"><span class="pre">&#64;c_ivt*(&#64;odt_skims['SOV_TIME']</span> <span class="pre">+</span> <span class="pre">dot_skims['SOV_TIME'])</span></code>
expression is travel time for the tour origin to desination at the tour start time plus the tour destination to tour origin at the tour end time.
The <code class="docutils literal notranslate"><span class="pre">odt_skims</span></code> and <code class="docutils literal notranslate"><span class="pre">dot_skims</span></code> objects are setup ahead-of-time to refer to the relevant skims for this model.  The <code class="docutils literal notranslate"><span class="pre">&#64;c_ivt</span></code> comes from the
tour mode choice coefficient file.  The tour mode choice model is a nested logit (NL) model and the nesting structure (including nesting
coefficients) is specified in the YAML settings file.</p>
<table border="1" class="docutils">
<colgroup>
<col width="31%" />
<col width="45%" />
<col width="13%" />
<col width="12%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Expression</th>
<th class="head">DRIVEALONEFREE</th>
<th class="head">DRIVEALONEPAY</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>DA - Unavailable</td>
<td>sov_available == False</td>
<td>-999</td>
<td>&#160;</td>
</tr>
<tr class="row-odd"><td>DA - In-vehicle time</td>
<td>&#64;c_ivt*(odt_skims[‘SOV_TIME’] + dot_skims[‘SOV_TIME’])</td>
<td>1</td>
<td>&#160;</td>
</tr>
<tr class="row-even"><td>DAP - Unavailable for age less than 16</td>
<td>age &lt; 16</td>
<td>&#160;</td>
<td>-999</td>
</tr>
<tr class="row-odd"><td>DAP - Unavailable for joint tours</td>
<td>is_joint == True</td>
<td>&#160;</td>
<td>-999</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="sampling-with-interaction">
<h3>Sampling with Interaction<a class="headerlink" href="#sampling-with-interaction" title="Permalink to this headline">¶</a></h3>
<p>Methods for expression handling, solving, and sampling (i.e. making multiple choices),
with interaction with the chooser table.</p>
<p>Sampling is done with replacement and a sample correction factor is calculated.  The factor is
calculated as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">freq</span> <span class="o">=</span> <span class="n">how</span> <span class="n">often</span> <span class="n">an</span> <span class="n">alternative</span> <span class="ow">is</span> <span class="n">sampled</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span> <span class="n">the</span> <span class="n">pick_count</span><span class="p">)</span>
<span class="n">prob</span> <span class="o">=</span> <span class="n">probability</span> <span class="n">of</span> <span class="n">the</span> <span class="n">alternative</span>
<span class="n">correction_factor</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">freq</span><span class="o">/</span><span class="n">prob</span><span class="p">)</span>

<span class="c1">#for example:</span>

<span class="n">freq</span>              <span class="mf">1.00</span>        <span class="mf">2.00</span>    <span class="mf">3.00</span>    <span class="mf">4.00</span>    <span class="mf">5.00</span>
<span class="n">prob</span>              <span class="mf">0.30</span>        <span class="mf">0.30</span>    <span class="mf">0.30</span>    <span class="mf">0.30</span>    <span class="mf">0.30</span>
<span class="n">correction</span> <span class="n">factor</span> <span class="mf">1.20</span>        <span class="mf">1.90</span>    <span class="mf">2.30</span>    <span class="mf">2.59</span>    <span class="mf">2.81</span>
</pre></div>
</div>
<p>As the alternative is oversampled, its utility goes up for final selection.  The unique set
of alternatives is passed to the final choice model and the correction factor is
included in the utility.</p>
<div class="section" id="id5">
<h4>API<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<span class="target" id="module-activitysim.core.interaction_sample"></span><dl class="function">
<dt id="activitysim.core.interaction_sample.interaction_sample">
<code class="descclassname">activitysim.core.interaction_sample.</code><code class="descname">interaction_sample</code><span class="sig-paren">(</span><em>choosers</em>, <em>alternatives</em>, <em>spec</em>, <em>sample_size</em>, <em>alt_col_name</em>, <em>allow_zero_probs=False</em>, <em>skims=None</em>, <em>locals_d=None</em>, <em>chunk_size=0</em>, <em>trace_label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.interaction_sample.interaction_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a simulation in the situation in which alternatives must
be merged with choosers because there are interaction terms or
because alternatives are being sampled.</p>
<p>optionally (if chunk_size &gt; 0) iterates over choosers in chunk_size chunks</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>choosers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">DataFrame of choosers</p>
</dd>
<dt><strong>alternatives</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">DataFrame of alternatives - will be merged with choosers and sampled</p>
</dd>
<dt><strong>spec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">A Pandas DataFrame that gives the specification of the variables to
compute and the coefficients for each variable.
Variable specifications must be in the table index and the
table should have only one column of coefficients.</p>
</dd>
<dt><strong>sample_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Sample alternatives with sample of given size.  By default is None,
which does not sample alternatives.</p>
</dd>
<dt><strong>alt_col_name: str</strong></dt>
<dd><p class="first last">name to give the sampled_alternative column</p>
</dd>
<dt><strong>skims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Skims object</span></dt>
<dd><p class="first last">The skims object is used to contain multiple matrices of
origin-destination impedances.  Make sure to also add it to the
locals_d below in order to access it in expressions.  The <em>only</em> job
of this method in regards to skims is to call set_df with the
dataframe that comes back from interacting choosers with
alternatives.  See the skims module for more documentation on how
the skims object is intended to be used.</p>
</dd>
<dt><strong>locals_d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dict</span></dt>
<dd><p class="first last">This is a dictionary of local variables that will be the environment
for an evaluation of an expression that begins with &#64;</p>
</dd>
<dt><strong>chunk_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">if chunk_size &gt; 0 iterates over choosers in chunk_size chunks</p>
</dd>
<dt><strong>trace_label: str</strong></dt>
<dd><p class="first last">This is the label to be used  for trace log file entries and dump file names
when household tracing enabled. No tracing occurs if label is empty or None.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>choices_df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first">A DataFrame where index should match the index of the choosers DataFrame
(except with sample_size rows for each choser row, one row for each alt sample)
and columns alt_col_name, prob, rand, pick_count</p>
<dl class="last docutils">
<dt>&lt;alt_col_name&gt;:</dt>
<dd><p class="first last">alt identifier from alternatives[&lt;alt_col_name&gt;</p>
</dd>
<dt>prob: float</dt>
<dd><p class="first last">the probability of the chosen alternative</p>
</dd>
<dt>pick_count <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">number of duplicate picks for chooser, alt</p>
</dd>
</dl>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.interaction_sample.make_sample_choices">
<code class="descclassname">activitysim.core.interaction_sample.</code><code class="descname">make_sample_choices</code><span class="sig-paren">(</span><em>choosers</em>, <em>probs</em>, <em>alternatives</em>, <em>sample_size</em>, <em>alternative_count</em>, <em>alt_col_name</em>, <em>allow_zero_probs</em>, <em>trace_label</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.interaction_sample.make_sample_choices" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>choosers</strong></dt>
<dd></dd>
<dt><strong>probs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas DataFrame</span></dt>
<dd><p class="first last">one row per chooser and one column per alternative</p>
</dd>
<dt><strong>alternatives</strong></dt>
<dd><p class="first last">dataframe with index containing alt ids</p>
</dd>
<dt><strong>sample_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">number of samples/choices to make</p>
</dd>
<dt><strong>alternative_count</strong></dt>
<dd></dd>
<dt><strong>alt_col_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd></dd>
<dt><strong>trace_label</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="simulate">
<span id="id6"></span><h3>Simulate<a class="headerlink" href="#simulate" title="Permalink to this headline">¶</a></h3>
<p>Methods for expression handling, solving, choosing (i.e. making choices) from a fixed set of choices
defined in the specification file.</p>
<div class="section" id="id7">
<h4>API<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<span class="target" id="module-activitysim.core.simulate"></span><dl class="function">
<dt id="activitysim.core.simulate.compute_base_probabilities">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">compute_base_probabilities</code><span class="sig-paren">(</span><em>nested_probabilities</em>, <em>nests</em>, <em>spec</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.compute_base_probabilities" title="Permalink to this definition">¶</a></dt>
<dd><p>compute base probabilities for nest leaves
Base probabilities will be the nest-adjusted probabilities of all leaves
This flattens or normalizes all the nested probabilities so that they have the proper global
relative values (the leaf probabilities sum to 1 for each row.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nested_probabilities</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">dataframe with the nested probabilities for nest leafs and nodes</p>
</dd>
<dt><strong>nests</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Nest tree dict from the model spec yaml file</p>
</dd>
<dt><strong>spec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.Dataframe</span></dt>
<dd><p class="first last">simple simulate spec so we can return columns in appropriate order</p>
</dd>
<dt><strong>Returns</strong></dt>
<dd></dd>
<dt><strong>——-</strong></dt>
<dd></dd>
<dt><strong>base_probabilities</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">Will have the index of <cite>nested_probabilities</cite> and columns for leaf base probabilities</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.compute_nested_exp_utilities">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">compute_nested_exp_utilities</code><span class="sig-paren">(</span><em>raw_utilities</em>, <em>nest_spec</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.compute_nested_exp_utilities" title="Permalink to this definition">¶</a></dt>
<dd><p>compute exponentiated nest utilities based on nesting coefficients</p>
<p>For nest nodes this is the exponentiated logsum of alternatives adjusted by nesting coefficient</p>
<p>leaf &lt;- exp( raw_utility )
nest &lt;- exp( ln(sum of exponentiated raw_utility of leaves) * nest_coefficient)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>raw_utilities</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">dataframe with the raw alternative utilities of all leaves
(what in non-nested logit would be the utilities of all the alternatives)</p>
</dd>
<dt><strong>nest_spec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Nest tree dict from the model spec yaml file</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nested_utilities</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">Will have the index of <cite>raw_utilities</cite> and columns for exponentiated leaf and node utilities</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.compute_nested_probabilities">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">compute_nested_probabilities</code><span class="sig-paren">(</span><em>nested_exp_utilities</em>, <em>nest_spec</em>, <em>trace_label</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.compute_nested_probabilities" title="Permalink to this definition">¶</a></dt>
<dd><p>compute nested probabilities for nest leafs and nodes
probability for nest alternatives is simply the alternatives’s local (to nest) probability
computed in the same way as the probability of non-nested alternatives in multinomial logit
i.e. the fractional share of the sum of the exponentiated utility of itself and its siblings
except in nested logit, its sib group is restricted to the nest</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nested_exp_utilities</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">dataframe with the exponentiated nested utilities of all leaves and nodes</p>
</dd>
<dt><strong>nest_spec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Nest tree dict from the model spec yaml file</p>
</dd>
<dt><strong>Returns</strong></dt>
<dd></dd>
<dt><strong>——-</strong></dt>
<dd></dd>
<dt><strong>nested_probabilities</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">Will have the index of <cite>nested_exp_utilities</cite> and columns for leaf and node probabilities</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.eval_mnl">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">eval_mnl</code><span class="sig-paren">(</span><em>choosers</em>, <em>spec</em>, <em>locals_d</em>, <em>custom_chooser</em>, <em>trace_label=None</em>, <em>trace_choice_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.eval_mnl" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a simulation for when the model spec does not involve alternative
specific data, e.g. there are no interactions with alternative
properties and no need to sample from alternatives.</p>
<p>Each row in spec computes a partial utility for each alternative,
by providing a spec expression (often a boolean 0-1 trigger)
and a column of utility coefficients for each alternative.</p>
<p>We compute the utility of each alternative by matrix-multiplication of eval results
with the utility coefficients in the spec alternative columns
yielding one row per chooser and one column per alternative</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>choosers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd></dd>
<dt><strong>spec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">A table of variable specifications and coefficient values.
Variable expressions should be in the table index and the table
should have a column for each alternative.</p>
</dd>
<dt><strong>locals_d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dict or None</span></dt>
<dd><p class="first last">This is a dictionary of local variables that will be the environment
for an evaluation of an expression that begins with &#64;</p>
</dd>
<dt><strong>custom_chooser</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function(probs, choosers, spec, trace_label) returns choices, rands</span></dt>
<dd><p class="first last">custom alternative to logit.make_choices</p>
</dd>
<dt><strong>trace_label: str</strong></dt>
<dd><p class="first last">This is the label to be used  for trace log file entries and dump file names
when household tracing enabled. No tracing occurs if label is empty or None.</p>
</dd>
<dt><strong>trace_choice_name: str</strong></dt>
<dd><p class="first last">This is the column label to be used in trace file csv dump of choices</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>choices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.Series</span></dt>
<dd><p class="first last">Index will be that of <cite>choosers</cite>, values will match the columns
of <cite>spec</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.eval_mnl_logsums">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">eval_mnl_logsums</code><span class="sig-paren">(</span><em>choosers</em>, <em>spec</em>, <em>locals_d</em>, <em>trace_label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.eval_mnl_logsums" title="Permalink to this definition">¶</a></dt>
<dd><p>like eval_nl except return logsums instead of making choices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>logsums</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.Series</span></dt>
<dd><p class="first last">Index will be that of <cite>choosers</cite>, values will be logsum across spec column values</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.eval_nl">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">eval_nl</code><span class="sig-paren">(</span><em>choosers</em>, <em>spec</em>, <em>nest_spec</em>, <em>locals_d</em>, <em>custom_chooser</em>, <em>trace_label=None</em>, <em>trace_choice_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.eval_nl" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a nested-logit simulation for when the model spec does not involve alternative
specific data, e.g. there are no interactions with alternative
properties and no need to sample from alternatives.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>choosers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd></dd>
<dt><strong>spec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">A table of variable specifications and coefficient values.
Variable expressions should be in the table index and the table
should have a column for each alternative.</p>
</dd>
<dt><strong>nest_spec:</strong></dt>
<dd><p class="first last">dictionary specifying nesting structure and nesting coefficients
(from the model spec yaml file)</p>
</dd>
<dt><strong>locals_d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dict or None</span></dt>
<dd><p class="first last">This is a dictionary of local variables that will be the environment
for an evaluation of an expression that begins with &#64;</p>
</dd>
<dt><strong>custom_chooser</strong> <span class="classifier-delimiter">:</span> <span class="classifier">function(probs, choosers, spec, trace_label) returns choices, rands</span></dt>
<dd><p class="first last">custom alternative to logit.make_choices</p>
</dd>
<dt><strong>trace_label: str</strong></dt>
<dd><p class="first last">This is the label to be used  for trace log file entries and dump file names
when household tracing enabled. No tracing occurs if label is empty or None.</p>
</dd>
<dt><strong>trace_choice_name: str</strong></dt>
<dd><p class="first last">This is the column label to be used in trace file csv dump of choices</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>choices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.Series</span></dt>
<dd><p class="first last">Index will be that of <cite>choosers</cite>, values will match the columns
of <cite>spec</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.eval_nl_logsums">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">eval_nl_logsums</code><span class="sig-paren">(</span><em>choosers</em>, <em>spec</em>, <em>nest_spec</em>, <em>locals_d</em>, <em>trace_label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.eval_nl_logsums" title="Permalink to this definition">¶</a></dt>
<dd><p>like eval_nl except return logsums instead of making choices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>logsums</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.Series</span></dt>
<dd><p class="first last">Index will be that of <cite>choosers</cite>, values will be nest logsum based on spec column values</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.eval_variables">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">eval_variables</code><span class="sig-paren">(</span><em>exprs</em>, <em>df</em>, <em>locals_d=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.eval_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a set of variable expressions from a spec in the context
of a given data table.</p>
<p>There are two kinds of supported expressions: “simple” expressions are
evaluated in the context of the DataFrame using DataFrame.eval.
This is the default type of expression.</p>
<p>Python expressions are evaluated in the context of this function using
Python’s eval function. Because we use Python’s eval this type of
expression supports more complex operations than a simple expression.
Python expressions are denoted by beginning with the &#64; character.
Users should take care that these expressions must result in
a Pandas Series.</p>
<p># FIXME - for performance, it is essential that spec and expression_values
# FIXME - not contain booleans when dotted with spec values
# FIXME - or the arrays will be converted to dtype=object within dot()</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>exprs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">sequence of str</span></dt>
<dd></dd>
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd></dd>
<dt><strong>locals_d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dict</span></dt>
<dd><p class="first last">This is a dictionary of local variables that will be the environment
for an evaluation of an expression that begins with &#64;</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>variables</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">Will have the index of <cite>df</cite> and columns of eval results of <cite>exprs</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.read_model_spec">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">read_model_spec</code><span class="sig-paren">(</span><em>model_settings=None</em>, <em>file_name=None</em>, <em>spec_dir=None</em>, <em>description_name='Description'</em>, <em>expression_name='Expression'</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.read_model_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a CSV model specification into a Pandas DataFrame or Series.</p>
<p>file_path : str   absolute or relative path to file</p>
<p>The CSV is expected to have columns for component descriptions
and expressions, plus one or more alternatives.</p>
<p>The CSV is required to have a header with column names. For example:</p>
<blockquote>
<div>Description,Expression,alt0,alt1,alt2</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>model_settings</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">name of spec_file is in model_settings[‘SPEC’] and file is relative to configs</p>
</dd>
<dt><strong>file_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">file_name id spec file in configs folder (or in spec_dir is specified)</p>
</dd>
<dt><strong>spec_dir</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">directory in which to fine spec file if not in configs</p>
</dd>
<dt><strong>description_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Name of the column in <cite>fname</cite> that contains the component description.</p>
</dd>
<dt><strong>expression_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Name of the column in <cite>fname</cite> that contains the component expression.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">The description column is dropped from the returned data and the
expression values are set as the table index.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.set_skim_wrapper_targets">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">set_skim_wrapper_targets</code><span class="sig-paren">(</span><em>df</em>, <em>skims</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.set_skim_wrapper_targets" title="Permalink to this definition">¶</a></dt>
<dd><p>Add the dataframe to the SkimDictWrapper object so that it can be dereferenced
using the parameters of the skims object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">Table to which to add skim data as new columns.
<cite>df</cite> is modified in-place.</p>
</dd>
<dt><strong>skims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">SkimDictWrapper or SkimStackWrapper object, or a list or dict of skims</span></dt>
<dd><p class="first last">The skims object is used to contain multiple matrices of
origin-destination impedances.  Make sure to also add it to the
locals_d below in order to access it in expressions.  The <em>only</em> job
of this method in regards to skims is to call set_df with the
dataframe that comes back from interacting choosers with
alternatives.  See the skims module for more documentation on how
the skims object is intended to be used.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.simple_simulate">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">simple_simulate</code><span class="sig-paren">(</span><em>choosers</em>, <em>spec</em>, <em>nest_spec</em>, <em>skims=None</em>, <em>locals_d=None</em>, <em>chunk_size=0</em>, <em>custom_chooser=None</em>, <em>trace_label=None</em>, <em>trace_choice_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.simple_simulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Run an MNL or NL simulation for when the model spec does not involve alternative
specific data, e.g. there are no interactions with alternative
properties and no need to sample from alternatives.</p>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.simple_simulate_logsums">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">simple_simulate_logsums</code><span class="sig-paren">(</span><em>choosers</em>, <em>spec</em>, <em>nest_spec</em>, <em>skims=None</em>, <em>locals_d=None</em>, <em>chunk_size=0</em>, <em>trace_label=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.simple_simulate_logsums" title="Permalink to this definition">¶</a></dt>
<dd><p>like simple_simulate except return logsums instead of making choices</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>logsums</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.Series</span></dt>
<dd><p class="first last">Index will be that of <cite>choosers</cite>, values will be nest logsum based on spec column values</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.simple_simulate_logsums_rpc">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">simple_simulate_logsums_rpc</code><span class="sig-paren">(</span><em>chunk_size</em>, <em>choosers</em>, <em>spec</em>, <em>nest_spec</em>, <em>trace_label</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.simple_simulate_logsums_rpc" title="Permalink to this definition">¶</a></dt>
<dd><p>calculate rows_per_chunk for simple_simulate_logsums</p>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.simulate.simple_simulate_rpc">
<code class="descclassname">activitysim.core.simulate.</code><code class="descname">simple_simulate_rpc</code><span class="sig-paren">(</span><em>chunk_size</em>, <em>choosers</em>, <em>spec</em>, <em>nest_spec</em>, <em>trace_label</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.simulate.simple_simulate_rpc" title="Permalink to this definition">¶</a></dt>
<dd><p>rows_per_chunk calculator for simple_simulate</p>
</dd></dl>

</div>
</div>
<div class="section" id="simulate-with-interaction">
<span id="id8"></span><h3>Simulate with Interaction<a class="headerlink" href="#simulate-with-interaction" title="Permalink to this headline">¶</a></h3>
<p>Methods for expression handling, solving, choosing (i.e. making choices),
with interaction with the chooser table.</p>
<div class="section" id="id9">
<h4>API<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h4>
<span class="target" id="module-activitysim.core.interaction_simulate"></span><dl class="function">
<dt id="activitysim.core.interaction_simulate.eval_interaction_utilities">
<code class="descclassname">activitysim.core.interaction_simulate.</code><code class="descname">eval_interaction_utilities</code><span class="sig-paren">(</span><em>spec</em>, <em>df</em>, <em>locals_d</em>, <em>trace_label</em>, <em>trace_rows</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.interaction_simulate.eval_interaction_utilities" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the utilities for a single-alternative spec evaluated in the context of df</p>
<p>We could compute the utilities for interaction datasets just as we do for simple_simulate
specs with multiple alternative columns byt calling eval_variables and then computing the
utilities by matrix-multiplication of eval results with the utility coefficients in the
spec alternative columns.</p>
<p>But interaction simulate computes the utilities of each alternative in the context of a
separate row in interaction dataset df, and so there is only one alternative in spec.
This turns out to be quite a bit faster (in this special case) than the pandas dot function.</p>
<p>For efficiency, we combine eval_variables and multiplication of coefficients into a single step,
so we don’t have to create a separate column for each partial utility. Instead, we simply
multiply the eval result by a single alternative coefficient and sum the partial utilities.</p>
<dl class="docutils">
<dt>spec <span class="classifier-delimiter">:</span> <span class="classifier">dataframe</span></dt>
<dd>one row per spec expression and one col with utility coefficient</dd>
<dt>df <span class="classifier-delimiter">:</span> <span class="classifier">dataframe</span></dt>
<dd>cross join (cartesian product) of choosers with alternatives
combines columns of choosers and alternatives
len(df) == len(choosers) * len(alternatives)
index values (non-unique) are index values from alternatives df</dd>
<dt>interaction_utilities <span class="classifier-delimiter">:</span> <span class="classifier">dataframe</span></dt>
<dd>the utility of each alternative is sum of the partial utilities determined by the
various spec expressions and their corresponding coefficients
yielding a dataframe  with len(interaction_df) rows and one utility column
having the same index as interaction_df (non-unique values from alternatives df)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>utilities</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">Will have the index of <cite>df</cite> and a single column of utilities</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.interaction_simulate.interaction_simulate">
<code class="descclassname">activitysim.core.interaction_simulate.</code><code class="descname">interaction_simulate</code><span class="sig-paren">(</span><em>choosers</em>, <em>alternatives</em>, <em>spec</em>, <em>skims=None</em>, <em>locals_d=None</em>, <em>sample_size=None</em>, <em>chunk_size=0</em>, <em>trace_label=None</em>, <em>trace_choice_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.interaction_simulate.interaction_simulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a simulation in the situation in which alternatives must
be merged with choosers because there are interaction terms or
because alternatives are being sampled.</p>
<p>optionally (if chunk_size &gt; 0) iterates over choosers in chunk_size chunks</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>choosers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">DataFrame of choosers</p>
</dd>
<dt><strong>alternatives</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">DataFrame of alternatives - will be merged with choosers, currently
without sampling</p>
</dd>
<dt><strong>spec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">A Pandas DataFrame that gives the specification of the variables to
compute and the coefficients for each variable.
Variable specifications must be in the table index and the
table should have only one column of coefficients.</p>
</dd>
<dt><strong>skims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Skims object</span></dt>
<dd><p class="first last">The skims object is used to contain multiple matrices of
origin-destination impedances.  Make sure to also add it to the
locals_d below in order to access it in expressions.  The <em>only</em> job
of this method in regards to skims is to call set_df with the
dataframe that comes back from interacting choosers with
alternatives.  See the skims module for more documentation on how
the skims object is intended to be used.</p>
</dd>
<dt><strong>locals_d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dict</span></dt>
<dd><p class="first last">This is a dictionary of local variables that will be the environment
for an evaluation of an expression that begins with &#64;</p>
</dd>
<dt><strong>sample_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">Sample alternatives with sample of given size.  By default is None,
which does not sample alternatives.</p>
</dd>
<dt><strong>chunk_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">if chunk_size &gt; 0 iterates over choosers in chunk_size chunks</p>
</dd>
<dt><strong>trace_label: str</strong></dt>
<dd><p class="first last">This is the label to be used  for trace log file entries and dump file names
when household tracing enabled. No tracing occurs if label is empty or None.</p>
</dd>
<dt><strong>trace_choice_name: str</strong></dt>
<dd><p class="first last">This is the column label to be used in trace file csv dump of choices</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>choices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.Series</span></dt>
<dd><p class="first last">A series where index should match the index of the choosers DataFrame
and values will match the index of the alternatives DataFrame -
choices are simulated in the standard Monte Carlo fashion</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="simulate-with-sampling-and-interaction">
<h3>Simulate with Sampling and Interaction<a class="headerlink" href="#simulate-with-sampling-and-interaction" title="Permalink to this headline">¶</a></h3>
<p>Methods for expression handling, solving, sampling (i.e. making multiple choices),
and choosing (i.e. making choices), with interaction with the chooser table.</p>
<div class="section" id="id10">
<h4>API<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h4>
<span class="target" id="module-activitysim.core.interaction_sample_simulate"></span><dl class="function">
<dt id="activitysim.core.interaction_sample_simulate.interaction_sample_simulate">
<code class="descclassname">activitysim.core.interaction_sample_simulate.</code><code class="descname">interaction_sample_simulate</code><span class="sig-paren">(</span><em>choosers</em>, <em>alternatives</em>, <em>spec</em>, <em>choice_column</em>, <em>allow_zero_probs=False</em>, <em>zero_prob_choice_val=None</em>, <em>skims=None</em>, <em>locals_d=None</em>, <em>chunk_size=0</em>, <em>trace_label=None</em>, <em>trace_choice_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.interaction_sample_simulate.interaction_sample_simulate" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a simulation in the situation in which alternatives must
be merged with choosers because there are interaction terms or
because alternatives are being sampled.</p>
<p>optionally (if chunk_size &gt; 0) iterates over choosers in chunk_size chunks</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>choosers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">DataFrame of choosers</p>
</dd>
<dt><strong>alternatives</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">DataFrame of alternatives - will be merged with choosers
index domain same as choosers, but repeated for each alternative</p>
</dd>
<dt><strong>spec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">A Pandas DataFrame that gives the specification of the variables to
compute and the coefficients for each variable.
Variable specifications must be in the table index and the
table should have only one column of coefficients.</p>
</dd>
<dt><strong>skims</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Skims object</span></dt>
<dd><p class="first last">The skims object is used to contain multiple matrices of
origin-destination impedances.  Make sure to also add it to the
locals_d below in order to access it in expressions.  The <em>only</em> job
of this method in regards to skims is to call set_df with the
dataframe that comes back from interacting choosers with
alternatives.  See the skims module for more documentation on how
the skims object is intended to be used.</p>
</dd>
<dt><strong>locals_d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dict</span></dt>
<dd><p class="first last">This is a dictionary of local variables that will be the environment
for an evaluation of an expression that begins with &#64;</p>
</dd>
<dt><strong>chunk_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">if chunk_size &gt; 0 iterates over choosers in chunk_size chunks</p>
</dd>
<dt><strong>trace_label: str</strong></dt>
<dd><p class="first last">This is the label to be used  for trace log file entries and dump file names
when household tracing enabled. No tracing occurs if label is empty or None.</p>
</dd>
<dt><strong>trace_choice_name: str</strong></dt>
<dd><p class="first last">This is the column label to be used in trace file csv dump of choices</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>choices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.Series</span></dt>
<dd><p class="first last">A series where index should match the index of the choosers DataFrame
and values will match the index of the alternatives DataFrame -
choices are simulated in the standard Monte Carlo fashion</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="assign">
<h3>Assign<a class="headerlink" href="#assign" title="Permalink to this headline">¶</a></h3>
<p>Alternative version of the expression evaluators in <a class="reference internal" href="#module-activitysim.core.simulate" title="activitysim.core.simulate"><code class="xref py py-mod docutils literal notranslate"><span class="pre">activitysim.core.simulate</span></code></a> that supports temporary variable assignment.
Temporary variables are identified in the expressions as starting with “_”, such as “_hh_density_bin”.  These
fields are not saved to the data pipeline store.  This feature is used by the <a class="reference internal" href="models.html#accessibility"><span class="std std-ref">Accessibility</span></a> model.</p>
<div class="section" id="id11">
<h4>API<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h4>
<span class="target" id="module-activitysim.core.assign"></span><dl class="class">
<dt id="activitysim.core.assign.NumpyLogger">
<em class="property">class </em><code class="descclassname">activitysim.core.assign.</code><code class="descname">NumpyLogger</code><span class="sig-paren">(</span><em>logger</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.assign.NumpyLogger" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="activitysim.core.assign.assign_variables">
<code class="descclassname">activitysim.core.assign.</code><code class="descname">assign_variables</code><span class="sig-paren">(</span><em>assignment_expressions</em>, <em>df</em>, <em>locals_dict</em>, <em>df_alias=None</em>, <em>trace_rows=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.assign.assign_variables" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a set of variable expressions from a spec in the context
of a given data table.</p>
<p>Expressions are evaluated using Python’s eval function.
Python expressions have access to variables in locals_d (and df being
accessible as variable df.) They also have access to previously assigned
targets as the assigned target name.</p>
<p>lowercase variables starting with underscore are temp variables (e.g. _local_var)
and not returned except in trace_results</p>
<p>uppercase variables starting with underscore are temp scalar variables (e.g. _LOCAL_SCALAR)
and not returned except in trace_assigned_locals
This is useful for defining general purpose local constants in expression file</p>
<p>Users should take care that expressions (other than temp scalar variables) should result in
a Pandas Series (scalars will be automatically promoted to series.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>assignment_expressions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame of target assignment expressions</span></dt>
<dd><p class="first last">target: target column names
expression: pandas or python expression to evaluate</p>
</dd>
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd></dd>
<dt><strong>locals_d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Dict</span></dt>
<dd><p class="first last">This is a dictionary of local variables that will be the environment
for an evaluation of “python” expression.</p>
</dd>
<dt><strong>trace_rows: series or array of bools to use as mask to select target rows to trace</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>variables</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">Will have the index of <cite>df</cite> and columns named by target and containing
the result of evaluating expression</p>
</dd>
<dt><strong>trace_df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame or None</span></dt>
<dd><p class="first last">a dataframe containing the eval result values for each assignment expression</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.assign.evaluate_constants">
<code class="descclassname">activitysim.core.assign.</code><code class="descname">evaluate_constants</code><span class="sig-paren">(</span><em>expressions</em>, <em>constants</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.assign.evaluate_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate a list of constant expressions - each one can depend on the one before
it.  These are usually used for the coefficients which have relationships
to each other.  So ivt=.7 and then ivt_lr=ivt*.9.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>expressions</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Series</span></dt>
<dd><p class="first last">the index are the names of the expressions which are
used in subsequent evals - thus naming the expressions is required.</p>
</dd>
<dt><strong>constants</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">will be passed as the scope of eval - usually a separate set of
constants are passed in here</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>d</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.assign.local_utilities">
<code class="descclassname">activitysim.core.assign.</code><code class="descname">local_utilities</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.assign.local_utilities" title="Permalink to this definition">¶</a></dt>
<dd><p>Dict of useful modules and functions to provides as locals for use in eval of expressions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>utility_dict</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">name, entity pairs of locals</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.assign.read_assignment_spec">
<code class="descclassname">activitysim.core.assign.</code><code class="descname">read_assignment_spec</code><span class="sig-paren">(</span><em>fname</em>, <em>description_name='Description'</em>, <em>target_name='Target'</em>, <em>expression_name='Expression'</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.assign.read_assignment_spec" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a CSV model specification into a Pandas DataFrame or Series.</p>
<p>The CSV is expected to have columns for component descriptions
targets, and expressions,</p>
<p>The CSV is required to have a header with column names. For example:</p>
<blockquote>
<div>Description,Target,Expression</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>fname</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Name of a CSV spec file.</p>
</dd>
<dt><strong>description_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Name of the column in <cite>fname</cite> that contains the component description.</p>
</dd>
<dt><strong>target_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Name of the column in <cite>fname</cite> that contains the component target.</p>
</dd>
<dt><strong>expression_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str, optional</span></dt>
<dd><p class="first last">Name of the column in <cite>fname</cite> that contains the component expression.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>spec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">dataframe with three columns: [‘description’ ‘target’ ‘expression’]</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.assign.uniquify_key">
<code class="descclassname">activitysim.core.assign.</code><code class="descname">uniquify_key</code><span class="sig-paren">(</span><em>dict</em>, <em>key</em>, <em>template='{} ({})'</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.assign.uniquify_key" title="Permalink to this definition">¶</a></dt>
<dd><p>rename key so there are no duplicates with keys in dict</p>
<p>e.g. if there is already a key named “dog”, the second key will be reformatted to “dog (2)”</p>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="choice-models">
<h2>Choice Models<a class="headerlink" href="#choice-models" title="Permalink to this headline">¶</a></h2>
<div class="section" id="logit">
<span id="logit-in-detail"></span><h3>Logit<a class="headerlink" href="#logit" title="Permalink to this headline">¶</a></h3>
<p>Multinomial logit (MNL) or Nested logit (NL) choice model.  These choice models depend on the foundational components of ActivitySim, such
as the expressions and data handling described in the <a class="reference internal" href="howitworks.html#id1"><span class="std std-ref">Execution Flow</span></a> section.</p>
<p>To specify and solve an MNL model:</p>
<ul class="simple">
<li>either specify <code class="docutils literal notranslate"><span class="pre">LOGIT_TYPE:</span> <span class="pre">MNL</span></code> in the model configuration YAML file or omit the setting</li>
<li>call either <code class="docutils literal notranslate"><span class="pre">simulate.simple_simulate()</span></code> or <code class="docutils literal notranslate"><span class="pre">simulate.interaction_simulate()</span></code> depending if the alternatives are interacted with the choosers or because alternatives are sampled</li>
</ul>
<p>To specify and solve an NL model:</p>
<ul class="simple">
<li>specify <code class="docutils literal notranslate"><span class="pre">LOGIT_TYPE:</span> <span class="pre">NL</span></code> in the model configuration YAML file</li>
<li>specify the nesting structure via the NESTS setting in the model configuration YAML file.  An example nested logit NESTS entry can be found in <code class="docutils literal notranslate"><span class="pre">example/configs/tour_mode_choice.yaml</span></code></li>
<li>call <code class="docutils literal notranslate"><span class="pre">simulate.simple_simulate()</span></code>.  The <code class="docutils literal notranslate"><span class="pre">simulate.interaction_simulate()</span></code> functionality is not yet supported for NL.</li>
</ul>
<div class="section" id="id12">
<h4>API<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<span class="target" id="module-activitysim.core.logit"></span><dl class="class">
<dt id="activitysim.core.logit.Nest">
<em class="property">class </em><code class="descclassname">activitysim.core.logit.</code><code class="descname">Nest</code><span class="sig-paren">(</span><em>name=None</em>, <em>level=0</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.logit.Nest" title="Permalink to this definition">¶</a></dt>
<dd><p>Data for a nest-logit node or leaf</p>
<p>This object is passed on yield when iterate over nest nodes (branch or leaf)
The nested logit design is stored in a yaml file as a tree of dict objects,
but using an object to pass the nest data makes the code a little more readable</p>
<p>An example nest specification is in the example tour mode choice model
yaml configuration file - example/configs/tour_mode_choice.yaml.</p>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.logit.count_nests">
<code class="descclassname">activitysim.core.logit.</code><code class="descname">count_nests</code><span class="sig-paren">(</span><em>nest_spec</em>, <em>type=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.logit.count_nests" title="Permalink to this definition">¶</a></dt>
<dd><p>count the nests of the specified type (or all nests if type is None)
return 0 if nest_spec is none</p>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.logit.each_nest">
<code class="descclassname">activitysim.core.logit.</code><code class="descname">each_nest</code><span class="sig-paren">(</span><em>nest_spec</em>, <em>type=None</em>, <em>post_order=False</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.logit.each_nest" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate over each nest or leaf node in the tree (of subtree)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>nest_spec</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">Nest tree dict from the model spec yaml file</p>
</dd>
<dt><strong>type</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">Nest class type to yield
None yields all nests
‘leaf’ yields only leaf nodes
‘branch’ yields only branch nodes</p>
</dd>
<dt><strong>post_order</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Bool</span></dt>
<dd><p class="first last">Should we iterate over the nodes of the tree in post-order or pre-order?
(post-order means we yield the alternatives sub-tree before current node.)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nest</strong> <span class="classifier-delimiter">:</span> <span class="classifier">Nest</span></dt>
<dd><p class="first last">Nest object with info about the current node (nest or leaf)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.logit.interaction_dataset">
<code class="descclassname">activitysim.core.logit.</code><code class="descname">interaction_dataset</code><span class="sig-paren">(</span><em>choosers</em>, <em>alternatives</em>, <em>sample_size=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.logit.interaction_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine choosers and alternatives into one table for the purposes
of creating interaction variables and/or sampling alternatives.</p>
<p>Any duplicate column names in alternatives table will be renamed with an ‘_r’ suffix.
(e.g. TAZ field in alternatives will appear as TAZ_r so that it can be targeted in a skim)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>choosers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd></dd>
<dt><strong>alternatives</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd></dd>
<dt><strong>sample_size</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int, optional</span></dt>
<dd><p class="first last">If sampling from alternatives for each chooser, this is
how many to sample.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>alts_sample</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">Merged choosers and alternatives with data repeated either
len(alternatives) or <cite>sample_size</cite> times.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.logit.make_choices">
<code class="descclassname">activitysim.core.logit.</code><code class="descname">make_choices</code><span class="sig-paren">(</span><em>probs</em>, <em>trace_label=None</em>, <em>trace_choosers=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.logit.make_choices" title="Permalink to this definition">¶</a></dt>
<dd><p>Make choices for each chooser from among a set of alternatives.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>probs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">Rows for choosers and columns for the alternatives from which they
are choosing. Values are expected to be valid probabilities across
each row, e.g. they should sum to 1.</p>
</dd>
<dt><strong>trace_choosers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.dataframe</span></dt>
<dd><p class="first last">the choosers df (for interaction_simulate) to facilitate the reporting of hh_id
by report_bad_choices because it can’t deduce hh_id from the interaction_dataset
which is indexed on index values from alternatives df</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>choices</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.Series</span></dt>
<dd><p class="first last">Maps chooser IDs (from <cite>probs</cite> index) to a choice, where the choice
is an index into the columns of <cite>probs</cite>.</p>
</dd>
<dt><strong>rands</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.Series</span></dt>
<dd><p class="first last">The random numbers used to make the choices (for debugging, tracing)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.logit.report_bad_choices">
<code class="descclassname">activitysim.core.logit.</code><code class="descname">report_bad_choices</code><span class="sig-paren">(</span><em>bad_row_map</em>, <em>df</em>, <em>trace_label</em>, <em>msg</em>, <em>trace_choosers=None</em>, <em>raise_error=True</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.logit.report_bad_choices" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>bad_row_map</strong></dt>
<dd></dd>
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">utils or probs dataframe</p>
</dd>
<dt><strong>msg</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">message describing the type of bad choice that necessitates error being thrown</p>
</dd>
<dt><strong>trace_choosers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.dataframe</span></dt>
<dd><p class="first last">the choosers df (for interaction_simulate) to facilitate the reporting of hh_id
because we  can’t deduce hh_id from the interaction_dataset which is indexed on index
values from alternatives df</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>raises RuntimeError</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.logit.utils_to_probs">
<code class="descclassname">activitysim.core.logit.</code><code class="descname">utils_to_probs</code><span class="sig-paren">(</span><em>utils</em>, <em>trace_label=None</em>, <em>exponentiated=False</em>, <em>allow_zero_probs=False</em>, <em>trace_choosers=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.logit.utils_to_probs" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a table of utilities to probabilities.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>utils</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">Rows should be choosers and columns should be alternatives.</p>
</dd>
<dt><strong>trace_label</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">label for tracing bad utility or probability values</p>
</dd>
<dt><strong>exponentiated</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">True if utilities have already been exponentiated</p>
</dd>
<dt><strong>allow_zero_probs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">if True value rows in which all utility alts are EXP_UTIL_MIN will result
in rows in probs to have all zero probability (and not sum to 1.0)
This is for the benefit of calculating probabilities of nested logit nests</p>
</dd>
<dt><strong>trace_choosers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.dataframe</span></dt>
<dd><p class="first last">the choosers df (for interaction_simulate) to facilitate the reporting of hh_id
by report_bad_choices because it can’t deduce hh_id from the interaction_dataset
which is indexed on index values from alternatives df</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>probs</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame</span></dt>
<dd><p class="first last">Will have the same index and columns as <cite>utils</cite>.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
</div>
<div class="section" id="person-time-windows">
<span id="time-windows"></span><h2>Person Time Windows<a class="headerlink" href="#person-time-windows" title="Permalink to this headline">¶</a></h2>
<p>The departure time and duration models require person time windows. Time windows are adjacent time
periods that are available for travel. Time windows are stored in a timetable table and each row is
a person and each time period (in the case of MTC TM1 is 5am to midnight in 1 hr increments) is a column.
Each column is coded as follows:</p>
<ul class="simple">
<li>0 - unscheduled, available</li>
<li>2 - scheduled, start of a tour, is available as the last period of another tour</li>
<li>4 - scheduled, end of a tour, is available as the first period of another tour</li>
<li>6 - scheduled, end or start of a tour, available for this period only</li>
<li>7 - scheduled, unavailable, middle of a tour</li>
</ul>
<p>A good example of a time window expression is <code class="docutils literal notranslate"><span class="pre">&#64;tt.previous_tour_ends(df.person_id,</span> <span class="pre">df.start)</span></code>.  This
uses the person id and the tour start period to check if a previous tour ends in the same time period.</p>
<div class="section" id="id13">
<h3>API<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<span class="target" id="module-activitysim.core.timetable"></span><dl class="class">
<dt id="activitysim.core.timetable.TimeTable">
<em class="property">class </em><code class="descclassname">activitysim.core.timetable.</code><code class="descname">TimeTable</code><span class="sig-paren">(</span><em>windows_df</em>, <em>tdd_alts_df</em>, <em>table_name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.timetable.TimeTable" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tdd_alts_df</span>      <span class="n">tdd_footprints_df</span>
<span class="n">start</span>  <span class="n">end</span>      <span class="s1">&#39;0&#39;</span> <span class="s1">&#39;1&#39;</span> <span class="s1">&#39;2&#39;</span> <span class="s1">&#39;3&#39;</span> <span class="s1">&#39;4&#39;</span><span class="o">...</span>
<span class="mi">5</span>      <span class="mi">5</span>    <span class="o">==&gt;</span>  <span class="mi">0</span>   <span class="mi">6</span>   <span class="mi">0</span>   <span class="mi">0</span>   <span class="mi">0</span> <span class="o">...</span>
<span class="mi">5</span>      <span class="mi">6</span>    <span class="o">==&gt;</span>  <span class="mi">0</span>   <span class="mi">2</span>   <span class="mi">4</span>   <span class="mi">0</span>   <span class="mi">0</span> <span class="o">...</span>
<span class="mi">5</span>      <span class="mi">7</span>    <span class="o">==&gt;</span>  <span class="mi">0</span>   <span class="mi">2</span>   <span class="mi">7</span>   <span class="mi">4</span>   <span class="mi">0</span> <span class="o">...</span>
</pre></div>
</div>
<dl class="method">
<dt id="activitysim.core.timetable.TimeTable.adjacent_window_after">
<code class="descname">adjacent_window_after</code><span class="sig-paren">(</span><em>self</em>, <em>window_row_ids</em>, <em>periods</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.timetable.TimeTable.adjacent_window_after" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of adjacent periods after specified period that are available
(not in the middle of another tour.)</p>
<p>Implements MTC TM1 macro &#64;&#64;adjWindowAfterThisPeriodAlt
Function name is kind of a misnomer, but parallels that used in MTC TM1 UECs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>window_row_ids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas Series int</span></dt>
<dd><p class="first last">series of window_row_ids indexed by tour_id</p>
</dd>
<dt><strong>periods</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas series int</span></dt>
<dd><p class="first last">series of tdd_alt ids, index irrelevant</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>pandas Series int</dt>
<dd><p class="first last">Number of adjacent windows indexed by window_row_ids.index</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.timetable.TimeTable.adjacent_window_before">
<code class="descname">adjacent_window_before</code><span class="sig-paren">(</span><em>self</em>, <em>window_row_ids</em>, <em>periods</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.timetable.TimeTable.adjacent_window_before" title="Permalink to this definition">¶</a></dt>
<dd><p>Return number of adjacent periods before specified period that are available
(not in the middle of another tour.)</p>
<p>Implements MTC TM1 macro &#64;&#64;getAdjWindowBeforeThisPeriodAlt
Function name is kind of a misnomer, but parallels that used in MTC TM1 UECs</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>window_row_ids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas Series int</span></dt>
<dd><p class="first last">series of window_row_ids indexed by tour_id</p>
</dd>
<dt><strong>periods</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas series int</span></dt>
<dd><p class="first last">series of tdd_alt ids, index irrelevant</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>pandas Series int</dt>
<dd><p class="first last">Number of adjacent windows indexed by window_row_ids.index</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.timetable.TimeTable.adjacent_window_run_length">
<code class="descname">adjacent_window_run_length</code><span class="sig-paren">(</span><em>self</em>, <em>window_row_ids</em>, <em>periods</em>, <em>before</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.timetable.TimeTable.adjacent_window_run_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of adjacent periods before or after specified period
that are available (not in the middle of another tour.)</p>
<p>Internal DRY method to implement adjacent_window_before and adjacent_window_after</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>window_row_ids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas Series int</span></dt>
<dd><p class="first last">series of window_row_ids indexed by tour_id</p>
</dd>
<dt><strong>periods</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas series int</span></dt>
<dd><p class="first last">series of tdd_alt ids, index irrelevant</p>
</dd>
<dt><strong>before</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">Specify desired run length is of adjacent window before (True) or after (False)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.timetable.TimeTable.assign">
<code class="descname">assign</code><span class="sig-paren">(</span><em>self</em>, <em>window_row_ids</em>, <em>tdds</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.timetable.TimeTable.assign" title="Permalink to this definition">¶</a></dt>
<dd><p>Assign tours (represented by tdd alt ids) to persons</p>
<p>Updates self.windows numpy array. Assignments will not ‘take’ outside this object
until/unless replace_table called or updated timetable retrieved by get_windows_df</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>window_row_ids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas Series</span></dt>
<dd><p class="first last">series of window_row_ids indexed by tour_id</p>
</dd>
<dt><strong>tdds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas series</span></dt>
<dd><p class="first last">series of tdd_alt ids, index irrelevant</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.timetable.TimeTable.assign_footprints">
<code class="descname">assign_footprints</code><span class="sig-paren">(</span><em>self</em>, <em>window_row_ids</em>, <em>footprints</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.timetable.TimeTable.assign_footprints" title="Permalink to this definition">¶</a></dt>
<dd><p>assign footprints for specified window_row_ids</p>
<p>This method is used for initialization of joint_tour timetables based on the
combined availability of the joint tour participants</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>window_row_ids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas Series</span></dt>
<dd><p class="first last">series of window_row_ids index irrelevant, but we want to use map()</p>
</dd>
<dt><strong>footprints</strong> <span class="classifier-delimiter">:</span> <span class="classifier">numpy array</span></dt>
<dd><p class="first last">with one row per window_row_id and one column per time period</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.timetable.TimeTable.assign_subtour_mask">
<code class="descname">assign_subtour_mask</code><span class="sig-paren">(</span><em>self</em>, <em>window_row_ids</em>, <em>tdds</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.timetable.TimeTable.assign_subtour_mask" title="Permalink to this definition">¶</a></dt>
<dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">index</span>     <span class="n">window_row_ids</span>   <span class="n">tdds</span>
<span class="mi">20973389</span>  <span class="mi">20973389</span>           <span class="mi">26</span>
<span class="mi">44612864</span>  <span class="mi">44612864</span>            <span class="mi">3</span>
<span class="mi">48954854</span>  <span class="mi">48954854</span>            <span class="mi">7</span>

<span class="n">tour</span> <span class="n">footprints</span>
<span class="p">[[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">2</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">4</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">2</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">4</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">[</span><span class="mi">0</span> <span class="mi">2</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">4</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">]]</span>

<span class="n">subtour_mask</span>
<span class="p">[[</span><span class="mi">7</span> <span class="mi">7</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span><span class="p">]</span>
<span class="p">[</span><span class="mi">7</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span><span class="p">]</span>
<span class="p">[</span><span class="mi">7</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span> <span class="mi">7</span><span class="p">]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.timetable.TimeTable.previous_tour_begins">
<code class="descname">previous_tour_begins</code><span class="sig-paren">(</span><em>self</em>, <em>window_row_ids</em>, <em>periods</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.timetable.TimeTable.previous_tour_begins" title="Permalink to this definition">¶</a></dt>
<dd><p>Does a previously scheduled tour begin in the specified period?</p>
<p>Implements MTC TM1 &#64;&#64;prevTourBeginsThisArrivalPeriodAlt</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>window_row_ids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas Series int</span></dt>
<dd><p class="first last">series of window_row_ids indexed by tour_id</p>
</dd>
<dt><strong>periods</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas series int</span></dt>
<dd><p class="first last">series of tdd_alt ids, index irrelevant</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>pandas Series boolean</dt>
<dd><p class="first last">indexed by window_row_ids.index</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.timetable.TimeTable.previous_tour_ends">
<code class="descname">previous_tour_ends</code><span class="sig-paren">(</span><em>self</em>, <em>window_row_ids</em>, <em>periods</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.timetable.TimeTable.previous_tour_ends" title="Permalink to this definition">¶</a></dt>
<dd><p>Does a previously scheduled tour end in the specified period?</p>
<p>Implements MTC TM1 &#64;&#64;prevTourEndsThisDeparturePeriodAlt</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>window_row_ids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas Series int</span></dt>
<dd><p class="first last">series of window_row_ids indexed by tour_id</p>
</dd>
<dt><strong>periods</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas series int</span></dt>
<dd><p class="first last">series of tdd_alt ids, index irrelevant (one period per window_row_id)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>pandas Series boolean</dt>
<dd><p class="first last">indexed by window_row_ids.index</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.timetable.TimeTable.remaining_periods_available">
<code class="descname">remaining_periods_available</code><span class="sig-paren">(</span><em>self</em>, <em>window_row_ids</em>, <em>starts</em>, <em>ends</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.timetable.TimeTable.remaining_periods_available" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine number of periods remaining available after the time window from starts to ends
is hypothetically scheduled</p>
<p>Implements MTC TM1 &#64;&#64;remainingPeriodsAvailableAlt</p>
<p>The start and end periods will always be available after scheduling, so ignore them.
The periods between start and end must be currently unscheduled, so assume they will become
unavailable after scheduling this window.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>window_row_ids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas Series int</span></dt>
<dd><p class="first last">series of window_row_ids indexed by tour_id</p>
</dd>
<dt><strong>starts</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas series int</span></dt>
<dd><p class="first last">series of tdd_alt ids, index irrelevant (one per window_row_id)</p>
</dd>
<dt><strong>ends</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas series int</span></dt>
<dd><p class="first last">series of tdd_alt ids, index irrelevant (one per window_row_id)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>available</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas Series int</span></dt>
<dd><p class="first last">number periods available indexed by window_row_ids.index</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.timetable.TimeTable.replace_table">
<code class="descname">replace_table</code><span class="sig-paren">(</span><em>self</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.timetable.TimeTable.replace_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Save or replace windows_df  DataFrame to pipeline with saved table name
(specified when object instantiated.)</p>
<p>This is a convenience function in case caller instantiates object in one context
(e.g. dependency injection) where it knows the pipeline table name, but wants to
checkpoint the table in another context where it does not know that name.</p>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.timetable.TimeTable.slice_windows_by_row_id">
<code class="descname">slice_windows_by_row_id</code><span class="sig-paren">(</span><em>self</em>, <em>window_row_ids</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.timetable.TimeTable.slice_windows_by_row_id" title="Permalink to this definition">¶</a></dt>
<dd><p>return windows array slice containing rows for specified window_row_ids
(in window_row_ids order)</p>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.timetable.TimeTable.tour_available">
<code class="descname">tour_available</code><span class="sig-paren">(</span><em>self</em>, <em>window_row_ids</em>, <em>tdds</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.timetable.TimeTable.tour_available" title="Permalink to this definition">¶</a></dt>
<dd><p>test whether time window allows tour with specific tdd alt’s time window</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>window_row_ids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas Series</span></dt>
<dd><p class="first last">series of window_row_ids indexed by tour_id</p>
</dd>
<dt><strong>tdds</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas series</span></dt>
<dd><p class="first last">series of tdd_alt ids, index irrelevant</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>available</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas Series of bool</span></dt>
<dd><p class="first last">with same index as window_row_ids.index (presumably tour_id, but we don’t care)</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="activitysim.core.timetable.TimeTable.window_periods_in_states">
<code class="descname">window_periods_in_states</code><span class="sig-paren">(</span><em>self</em>, <em>window_row_ids</em>, <em>periods</em>, <em>states</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.timetable.TimeTable.window_periods_in_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Return boolean array indicating whether specified window periods are in list of states.</p>
<p>Internal DRY method to implement previous_tour_ends and previous_tour_begins</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>window_row_ids</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas Series int</span></dt>
<dd><p class="first last">series of window_row_ids indexed by tour_id</p>
</dd>
<dt><strong>periods</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas series int</span></dt>
<dd><p class="first last">series of tdd_alt ids, index irrelevant (one period per window_row_id)</p>
</dd>
<dt><strong>states</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list of int</span></dt>
<dd><p class="first last">presumably (e.g. I_EMPTY, I_START…)</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>pandas Series boolean</dt>
<dd><p class="first last">indexed by window_row_ids.index</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="activitysim.core.timetable.create_timetable_windows">
<code class="descclassname">activitysim.core.timetable.</code><code class="descname">create_timetable_windows</code><span class="sig-paren">(</span><em>rows</em>, <em>tdd_alts</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.timetable.create_timetable_windows" title="Permalink to this definition">¶</a></dt>
<dd><p>create an empty (all available) timetable with one window row per rows.index</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>rows - pd.DataFrame or Series or orca.DataFrameWrapper</strong></dt>
<dd><p class="first last">all we care about is the index</p>
</dd>
<dt><strong>tdd_alts - pd.DataFrame</strong></dt>
<dd><p class="first last">We expect a start and end column, and create a timetable to accomodate all alts
(with on window of padding at each end)</p>
</dd>
<dt><strong>so if start is 5 and end is 23, we return something like this:</strong></dt>
<dd><p class="first last">4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24</p>
</dd>
<dt><strong>person_id</strong></dt>
<dd></dd>
<dt><strong>30       0  0  0  0  0  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0</strong></dt>
<dd></dd>
<dt><strong>109      0  0  0  0  0  0   0   0   0   0   0   0   0   0   0   0   0   0   0   0   0</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>pd.DataFrame indexed by rows.index, and one column of int8 for each time window (plus padding)</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="helpers">
<h2>Helpers<a class="headerlink" href="#helpers" title="Permalink to this headline">¶</a></h2>
<div class="section" id="chunk">
<span id="chunk-in-detail"></span><h3>Chunk<a class="headerlink" href="#chunk" title="Permalink to this headline">¶</a></h3>
<p>Chunking management</p>
<div class="section" id="id14">
<h4>API<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h4>
<span class="target" id="module-activitysim.core.chunk"></span><dl class="function">
<dt id="activitysim.core.chunk.chunked_choosers_and_alts">
<code class="descclassname">activitysim.core.chunk.</code><code class="descname">chunked_choosers_and_alts</code><span class="sig-paren">(</span><em>choosers</em>, <em>alternatives</em>, <em>rows_per_chunk</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.chunk.chunked_choosers_and_alts" title="Permalink to this definition">¶</a></dt>
<dd><p>generator to iterate over choosers and alternatives in chunk_size chunks</p>
<p>like chunked_choosers, but also chunks alternatives
for use with sampled alternatives which will have different alternatives (and numbers of alts)</p>
<p>There may be up to sample_size (or as few as one) alternatives for each chooser
because alternatives may have been sampled more than once,  but pick_count for those
alternatives will always sum to sample_size.</p>
<p>When we chunk the choosers, we need to take care chunking the alternatives as there are
varying numbers of them for each chooser. Since alternatives appear in the same order
as choosers, we can use cumulative pick_counts to identify boundaries of sets of alternatives</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>choosers</strong></dt>
<dd></dd>
<dt><strong>alternatives</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas DataFrame</span></dt>
<dd><p class="first last">sample alternatives including pick_count column in same order as choosers</p>
</dd>
<dt><strong>rows_per_chunk</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Yields:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>i</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">one-based index of current chunk</p>
</dd>
<dt><strong>num_chunks</strong> <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">total number of chunks that will be yielded</p>
</dd>
<dt><strong>choosers</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas DataFrame slice</span></dt>
<dd><p class="first last">chunk of choosers</p>
</dd>
<dt><strong>alternatives</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas DataFrame slice</span></dt>
<dd><p class="first last">chunk of alternatives for chooser chunk</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="utilities">
<h3>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h3>
<p>Vectorized helper functions</p>
<div class="section" id="id15">
<h4>API<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h4>
<span class="target" id="module-activitysim.core.util"></span><dl class="function">
<dt id="activitysim.core.util.assign_in_place">
<code class="descclassname">activitysim.core.util.</code><code class="descname">assign_in_place</code><span class="sig-paren">(</span><em>df</em>, <em>df2</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.util.assign_in_place" title="Permalink to this definition">¶</a></dt>
<dd><p>update existing row values in df from df2, adding columns to df if they are not there</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pd.DataFrame</span></dt>
<dd><p class="first last">assignment left-hand-side (dest)</p>
</dd>
<dt><strong>df2: pd.DataFrame</strong></dt>
<dd><p class="first last">assignment right-hand-side (source)</p>
</dd>
<dt><strong>Returns</strong></dt>
<dd></dd>
<dt><strong>——-</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.util.left_merge_on_index_and_col">
<code class="descclassname">activitysim.core.util.</code><code class="descname">left_merge_on_index_and_col</code><span class="sig-paren">(</span><em>left_df</em>, <em>right_df</em>, <em>join_col</em>, <em>target_col</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.util.left_merge_on_index_and_col" title="Permalink to this definition">¶</a></dt>
<dd><p>like pandas left merge, but join on both index and a specified join_col</p>
<p>FIXME - for now return a series of ov values from specified right_df target_col</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>left_df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas DataFrame</span></dt>
<dd><p class="first last">index name assumed to be same as that of right_df</p>
</dd>
<dt><strong>right_df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas DataFrame</span></dt>
<dd><p class="first last">index name assumed to be same as that of left_df</p>
</dd>
<dt><strong>join_col</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of column to join on (in addition to index values)
should have same name in both dataframes</p>
</dd>
<dt><strong>target_col</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">name of column from right_df whose joined values should be returned as series</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>target_series</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas Series</span></dt>
<dd><p class="first last">series of target_col values with same index as left_df
i.e. values joined to left_df from right_df with index of left_df</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.util.other_than">
<code class="descclassname">activitysim.core.util.</code><code class="descname">other_than</code><span class="sig-paren">(</span><em>groups</em>, <em>bools</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.util.other_than" title="Permalink to this definition">¶</a></dt>
<dd><p>Construct a Series that has booleans indicating the presence of
something- or someone-else with a certain property within a group.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>groups</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.Series</span></dt>
<dd><p class="first last">A column with the same index as <cite>bools</cite> that defines the grouping
of <cite>bools</cite>. The <cite>bools</cite> Series will be used to index <cite>groups</cite> and
then the grouped values will be counted.</p>
</dd>
<dt><strong>bools</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.Series</span></dt>
<dd><p class="first last">A boolean Series indicating where the property of interest is present.
Should have the same index as <cite>groups</cite>.</p>
</dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>others</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.Series</span></dt>
<dd><p class="first last">A boolean Series with the same index as <cite>groups</cite> and <cite>bools</cite>
indicating whether there is something- or something-else within
a group with some property (as indicated by <cite>bools</cite>).</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.util.quick_loc_df">
<code class="descclassname">activitysim.core.util.</code><code class="descname">quick_loc_df</code><span class="sig-paren">(</span><em>loc_list</em>, <em>target_df</em>, <em>attribute=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.util.quick_loc_df" title="Permalink to this definition">¶</a></dt>
<dd><p>faster replacement for target_df.loc[loc_list] or target_df.loc[loc_list][attribute]</p>
<p>pandas DataFrame.loc[] indexing doesn’t scale for large arrays (e.g. &gt; 1,000,000 elements)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>loc_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list-like (numpy.ndarray, pandas.Int64Index, or pandas.Series)</span></dt>
<dd></dd>
<dt><strong>target_df</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.DataFrame containing column named attribute</span></dt>
<dd></dd>
<dt><strong>attribute</strong> <span class="classifier-delimiter">:</span> <span class="classifier">name of column from loc_list to return (or none for all columns)</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>pandas.DataFrame or, if attribbute specified, pandas.Series</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.util.quick_loc_series">
<code class="descclassname">activitysim.core.util.</code><code class="descname">quick_loc_series</code><span class="sig-paren">(</span><em>loc_list</em>, <em>target_series</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.util.quick_loc_series" title="Permalink to this definition">¶</a></dt>
<dd><p>faster replacement for target_series.loc[loc_list]</p>
<p>pandas Series.loc[] indexing doesn’t scale for large arrays (e.g. &gt; 1,000,000 elements)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>loc_list</strong> <span class="classifier-delimiter">:</span> <span class="classifier">list-like (numpy.ndarray, pandas.Int64Index, or pandas.Series)</span></dt>
<dd></dd>
<dt><strong>target_series</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.Series</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt>pandas.Series</dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.util.reindex">
<code class="descclassname">activitysim.core.util.</code><code class="descname">reindex</code><span class="sig-paren">(</span><em>series1</em>, <em>series2</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.util.reindex" title="Permalink to this definition">¶</a></dt>
<dd><p>This reindexes the first series by the second series.  This is an extremely
common operation that does not appear to  be in Pandas at this time.
If anyone knows of an easier way to do this in Pandas, please inform the
UrbanSim developers.</p>
<p>The canonical example would be a parcel series which has an index which is
parcel_ids and a value which you want to fetch, let’s say it’s land_area.
Another dataset, let’s say of buildings has a series which indicate the
parcel_ids that the buildings are located on, but which does not have
land_area.  If you pass parcels.land_area as the first series and
buildings.parcel_id as the second series, this function returns a series
which is indexed by buildings and has land_area as values and can be
added to the buildings dataset.</p>
<p>In short, this is a join on to a different table using a foreign key
stored in the current table, but with only one attribute rather than
for a full dataset.</p>
<p>This is very similar to the pandas “loc” function or “reindex” function,
but neither of those functions return the series indexed on the current
table.  In both of those cases, the series would be indexed on the foreign
table and would require a second step to change the index.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first docutils">
<dt><strong>series1, series2</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.Series</span></dt>
<dd></dd>
</dl>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>reindexed</strong> <span class="classifier-delimiter">:</span> <span class="classifier">pandas.Series</span></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="config">
<h3>Config<a class="headerlink" href="#config" title="Permalink to this headline">¶</a></h3>
<p>Helper functions for configuring a model run</p>
<div class="section" id="id16">
<h4>API<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h4>
<span class="target" id="module-activitysim.core.config"></span><dl class="function">
<dt id="activitysim.core.config.filter_warnings">
<code class="descclassname">activitysim.core.config.</code><code class="descname">filter_warnings</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.config.filter_warnings" title="Permalink to this definition">¶</a></dt>
<dd><p>set warning filter to ‘strict’ if specified in settings</p>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.config.get_logit_model_settings">
<code class="descclassname">activitysim.core.config.</code><code class="descname">get_logit_model_settings</code><span class="sig-paren">(</span><em>model_settings</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.config.get_logit_model_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Read nest spec (for nested logit) from model settings file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>nests</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">dictionary specifying nesting structure and nesting coefficients</p>
</dd>
<dt><strong>constants</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">dictionary of constants to add to locals for use by expressions in model spec</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.config.get_model_constants">
<code class="descclassname">activitysim.core.config.</code><code class="descname">get_model_constants</code><span class="sig-paren">(</span><em>model_settings</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.config.get_model_constants" title="Permalink to this definition">¶</a></dt>
<dd><p>Read constants from model settings file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>constants</strong> <span class="classifier-delimiter">:</span> <span class="classifier">dict</span></dt>
<dd><p class="first last">dictionary of constants to add to locals for use by expressions in model spec</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.config.handle_standard_args">
<code class="descclassname">activitysim.core.config.</code><code class="descname">handle_standard_args</code><span class="sig-paren">(</span><em>parser=None</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.config.handle_standard_args" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Adds ‘standard’ activitysim arguments:</dt>
<dd>–config : specify path to config_dir
–output : specify path to output_dir
–data   : specify path to data_dir</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>parser</strong> <span class="classifier-delimiter">:</span> <span class="classifier">argparse.ArgumentParser or None</span></dt>
<dd><p class="first last">to  custom argument handling, pass in a parser with arguments added
and handle them based on returned args. This method will hand the args it adds</p>
</dd>
<dt><strong>Returns</strong></dt>
<dd></dd>
<dt><strong>——-</strong></dt>
<dd></dd>
<dt><strong>injectables - array of injectables altered by args</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="data">
<dt id="activitysim.core.config.logger">
<code class="descclassname">activitysim.core.config.</code><code class="descname">logger</code><em class="property"> = &lt;logging.Logger object&gt;</em><a class="headerlink" href="#activitysim.core.config.logger" title="Permalink to this definition">¶</a></dt>
<dd><p>default injectables</p>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.config.read_model_settings">
<code class="descclassname">activitysim.core.config.</code><code class="descname">read_model_settings</code><span class="sig-paren">(</span><em>file_name</em>, <em>mandatory=False</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.config.read_model_settings" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>file_name</strong> <span class="classifier-delimiter">:</span> <span class="classifier">str</span></dt>
<dd><p class="first last">yaml file name</p>
</dd>
<dt><strong>mandatory</strong> <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">throw error if file empty or not found</p>
</dd>
<dt><strong>Returns</strong></dt>
<dd></dd>
<dt><strong>——-</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="inject">
<span id="id17"></span><h3>Inject<a class="headerlink" href="#inject" title="Permalink to this headline">¶</a></h3>
<p>Wrap ORCA class to make it easier to track and manage interaction with the data pipeline.</p>
<div class="section" id="id18">
<h4>API<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h4>
<span class="target" id="module-activitysim.core.inject"></span><dl class="function">
<dt id="activitysim.core.inject.reinject_decorated_tables">
<code class="descclassname">activitysim.core.inject.</code><code class="descname">reinject_decorated_tables</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.inject.reinject_decorated_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>reinject the decorated tables (and columns)</p>
</dd></dl>

</div>
</div>
<div class="section" id="mem">
<h3>Mem<a class="headerlink" href="#mem" title="Permalink to this headline">¶</a></h3>
<p>Helper functions for tracking memory usage</p>
<div class="section" id="id19">
<h4>API<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h4>
<span class="target" id="module-activitysim.core.mem"></span></div>
</div>
<div class="section" id="output">
<h3>Output<a class="headerlink" href="#output" title="Permalink to this headline">¶</a></h3>
<p>Write output files and track skim usage.</p>
<div class="section" id="id20">
<h4>API<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h4>
<span class="target" id="module-activitysim.core.steps.output"></span><dl class="function">
<dt id="activitysim.core.steps.output.track_skim_usage">
<code class="descclassname">activitysim.core.steps.output.</code><code class="descname">track_skim_usage</code><span class="sig-paren">(</span><em>output_dir</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.steps.output.track_skim_usage" title="Permalink to this definition">¶</a></dt>
<dd><p>write statistics on skim usage (diagnostic to detect loading of un-needed skims)</p>
<p>FIXME - have not yet implemented a facility to avoid loading of unused skims</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output_dir: str</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.steps.output.write_data_dictionary">
<code class="descclassname">activitysim.core.steps.output.</code><code class="descname">write_data_dictionary</code><span class="sig-paren">(</span><em>output_dir</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.steps.output.write_data_dictionary" title="Permalink to this definition">¶</a></dt>
<dd><p>Write table_name, number of rows, columns, and bytes for each checkpointed table</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output_dir: str</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="activitysim.core.steps.output.write_tables">
<code class="descclassname">activitysim.core.steps.output.</code><code class="descname">write_tables</code><span class="sig-paren">(</span><em>output_dir</em><span class="sig-paren">)</span><a class="headerlink" href="#activitysim.core.steps.output.write_tables" title="Permalink to this definition">¶</a></dt>
<dd><p>Write pipeline tables as csv files (in output directory) as specified by output_tables list
in settings file.</p>
<p>‘output_tables’ can specify either a list of output tables to include or to skip
if no output_tables list is specified, then no checkpointed tables will be written</p>
<p>To write all output tables EXCEPT the households and persons tables:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">output_tables</span><span class="p">:</span>
  <span class="n">action</span><span class="p">:</span> <span class="n">skip</span>
  <span class="n">tables</span><span class="p">:</span>
    <span class="o">-</span> <span class="n">households</span>
    <span class="o">-</span> <span class="n">persons</span>
</pre></div>
</div>
<p>To write ONLY the households table:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">output_tables</span><span class="p">:</span>
  <span class="n">action</span><span class="p">:</span> <span class="n">include</span>
  <span class="n">tables</span><span class="p">:</span>
     <span class="o">-</span> <span class="n">households</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><dl class="first last docutils">
<dt><strong>output_dir: str</strong></dt>
<dd></dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>
<div class="section" id="tests">
<h3>Tests<a class="headerlink" href="#tests" title="Permalink to this headline">¶</a></h3>
<p>See activitysim.core.test</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="development.html" class="btn btn-neutral float-right" title="Software Development" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="howitworks.html" class="btn btn-neutral float-left" title="How the System Works" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright contributing authors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>